#![allow(non_upper_case_globals, non_camel_case_types, non_snake_case, unused)]
/* automatically generated by rust-bindgen 0.69.4 */

pub const CY_WCM_MAX_SSID_LEN: u32 = 32;
pub const CY_WCM_MAX_PASSPHRASE_LEN: u32 = 63;
pub const CY_WCM_MIN_PASSPHRASE_LEN: u32 = 8;
pub const CY_WCM_MAC_ADDR_LEN: u32 = 6;
pub const CY_WCM_MAX_IE_LENGTH: u32 = 3;
pub const CY_WCM_WPS_PIN_LENGTH: u32 = 9;
pub const CY_WCM_MAXIMUM_CALLBACKS_COUNT: u32 = 5;
#[doc = " @brief Provides the result of an operation as a structured bitfield.\n\n @note A newer version @ref cy_rslt_decode_t is also available for improved\n debugging experience.\n\n See the \\ref anchor_general_description \"General Description\"\n for more details on structure and usage."]
pub type cy_rslt_t = u32;
#[doc = "< Initial assoc."]
pub const cy_wcm_reason_code_CY_WCM_REASON_INITIAL_ASSOC: cy_wcm_reason_code = 0;
#[doc = "< Roamed due to low RSSI."]
pub const cy_wcm_reason_code_CY_WCM_REASON_LOW_RSSI: cy_wcm_reason_code = 1;
#[doc = "< Roamed due to DEAUTH indication."]
pub const cy_wcm_reason_code_CY_WCM_REASON_DEAUTH: cy_wcm_reason_code = 2;
#[doc = "< Roamed due to DISASSOC indication."]
pub const cy_wcm_reason_code_CY_WCM_REASON_DISASSOC: cy_wcm_reason_code = 3;
#[doc = "< Roamed due to lost beacons."]
pub const cy_wcm_reason_code_CY_WCM_REASON_BCNS_LOST: cy_wcm_reason_code = 4;
#[doc = "< Roamed due to fast roam failure."]
pub const cy_wcm_reason_code_CY_WCM_REASON_FAST_ROAM_FAILED: cy_wcm_reason_code = 5;
#[doc = "< Roamed due to request by AP."]
pub const cy_wcm_reason_code_CY_WCM_REASON_DIRECTED_ROAM: cy_wcm_reason_code = 6;
#[doc = "< Roamed due to TSPEC rejection."]
pub const cy_wcm_reason_code_CY_WCM_REASON_TSPEC_REJECTED: cy_wcm_reason_code = 7;
#[doc = "< Roamed due to finding better AP."]
pub const cy_wcm_reason_code_CY_WCM_REASON_BETTER_AP: cy_wcm_reason_code = 8;
#[doc = "< Generated on any change in nan_mac status."]
pub const cy_wcm_reason_code_CY_WCM_REASON_NAN_EVENT_STATUS_CHG: cy_wcm_reason_code = 9;
#[doc = "< Merged to a NAN cluster."]
pub const cy_wcm_reason_code_CY_WCM_REASON_NAN_EVENT_MERGE: cy_wcm_reason_code = 10;
#[doc = "< NAN stopped."]
pub const cy_wcm_reason_code_CY_WCM_REASON_NAN_EVENT_STOP: cy_wcm_reason_code = 11;
#[doc = "< NAN P2P EVENT."]
pub const cy_wcm_reason_code_CY_WCM_REASON_NAN_EVENT_P2P: cy_wcm_reason_code = 12;
#[doc = "< Event for beginning of P2P further availability window."]
pub const cy_wcm_reason_code_CY_WCM_REASON_NAN_EVENT_WINDOW_BEGIN_P2P: cy_wcm_reason_code = 13;
pub const cy_wcm_reason_code_CY_WCM_REASON_NAN_EVENT_WINDOW_BEGIN_MESH: cy_wcm_reason_code = 14;
pub const cy_wcm_reason_code_CY_WCM_REASON_NAN_EVENT_WINDOW_BEGIN_IBSS: cy_wcm_reason_code = 15;
pub const cy_wcm_reason_code_CY_WCM_REASON_NAN_EVENT_WINDOW_BEGIN_RANGING: cy_wcm_reason_code = 16;
#[doc = "< Event for post discovery data."]
pub const cy_wcm_reason_code_CY_WCM_REASON_NAN_EVENT_POST_DISC: cy_wcm_reason_code = 17;
#[doc = "< Event for Data IF add."]
pub const cy_wcm_reason_code_CY_WCM_REASON_NAN_EVENT_DATA_IF_ADD: cy_wcm_reason_code = 18;
#[doc = "< Event for peer add."]
pub const cy_wcm_reason_code_CY_WCM_REASON_NAN_EVENT_DATA_PEER_ADD: cy_wcm_reason_code = 19;
#[doc = "< Data indication to host."]
pub const cy_wcm_reason_code_CY_WCM_REASON_NAN_EVENT_DATA_IND: cy_wcm_reason_code = 20;
#[doc = "< Data response to host."]
pub const cy_wcm_reason_code_CY_WCM_REASON_NAN_EVENT_DATA_CONF: cy_wcm_reason_code = 21;
#[doc = "< Entire service discovery frame."]
pub const cy_wcm_reason_code_CY_WCM_REASON_NAN_EVENT_SDF_RX: cy_wcm_reason_code = 22;
pub const cy_wcm_reason_code_CY_WCM_REASON_NAN_EVENT_DATA_END: cy_wcm_reason_code = 23;
#[doc = "< Received beacon payload."]
pub const cy_wcm_reason_code_CY_WCM_REASON_NAN_EVENT_BCN_RX: cy_wcm_reason_code = 24;
#[doc = "< Encryption mismatch."]
pub const cy_wcm_reason_code_CY_WCM_REASON_PRUNE_ENCR_MISMATCH: cy_wcm_reason_code = 257;
#[doc = "< AP uses a broadcast BSSID."]
pub const cy_wcm_reason_code_CY_WCM_REASON_PRUNE_BCAST_BSSID: cy_wcm_reason_code = 258;
#[doc = "< STA's MAC address is in AP's MAC deny list."]
pub const cy_wcm_reason_code_CY_WCM_REASON_PRUNE_MAC_DENY: cy_wcm_reason_code = 259;
#[doc = "< STA's MAC addrress is not in AP's MAC allow list."]
pub const cy_wcm_reason_code_CY_WCM_REASON_PRUNE_MAC_NA: cy_wcm_reason_code = 260;
#[doc = "< AP not allowed due to regulatory restriction."]
pub const cy_wcm_reason_code_CY_WCM_REASON_PRUNE_REG_PASSV: cy_wcm_reason_code = 261;
#[doc = "< AP does not support STA locale spectrum management."]
pub const cy_wcm_reason_code_CY_WCM_REASON_PRUNE_SPCT_MGMT: cy_wcm_reason_code = 262;
#[doc = "< AP is on a radar channel of STA locale."]
pub const cy_wcm_reason_code_CY_WCM_REASON_PRUNE_RADAR: cy_wcm_reason_code = 263;
#[doc = "< STA does not support AP's RSN."]
pub const cy_wcm_reason_code_CY_WCM_REASON_RSN_MISMATCH: cy_wcm_reason_code = 264;
#[doc = "< No rates in common with AP."]
pub const cy_wcm_reason_code_CY_WCM_REASON_PRUNE_NO_COMMON_RATES: cy_wcm_reason_code = 265;
#[doc = "< STA does not support all basic rates of BSS."]
pub const cy_wcm_reason_code_CY_WCM_REASON_PRUNE_BASIC_RATES: cy_wcm_reason_code = 266;
#[doc = "< CCX FAST ROAM: prune previous AP."]
pub const cy_wcm_reason_code_CY_WCM_REASON_PRUNE_CCXFAST_PREVAP: cy_wcm_reason_code = 267;
#[doc = "< BSS's cipher not supported."]
pub const cy_wcm_reason_code_CY_WCM_REASON_PRUNE_CIPHER_NA: cy_wcm_reason_code = 268;
#[doc = "< AP is already known to us as a STA."]
pub const cy_wcm_reason_code_CY_WCM_REASON_PRUNE_KNOWN_STA: cy_wcm_reason_code = 269;
#[doc = "< CCX FAST ROAM: prune unqualified AP."]
pub const cy_wcm_reason_code_CY_WCM_REASON_PRUNE_CCXFAST_DROAM: cy_wcm_reason_code = 270;
#[doc = "< AP is already known to us as a WDS peer."]
pub const cy_wcm_reason_code_CY_WCM_REASON_PRUNE_WDS_PEER: cy_wcm_reason_code = 271;
#[doc = "< QBSS LOAD - AAC is too low."]
pub const cy_wcm_reason_code_CY_WCM_REASON_PRUNE_QBSS_LOAD: cy_wcm_reason_code = 272;
#[doc = "< Prune home AP."]
pub const cy_wcm_reason_code_CY_WCM_REASON_PRUNE_HOME_AP: cy_wcm_reason_code = 273;
#[doc = "< Prune blocked AP."]
pub const cy_wcm_reason_code_CY_WCM_REASON_PRUNE_AP_BLOCKED: cy_wcm_reason_code = 274;
#[doc = "< Prune due to diagnostic mode not supported."]
pub const cy_wcm_reason_code_CY_WCM_REASON_PRUNE_NO_DIAG_SUPPORT: cy_wcm_reason_code = 275;
#[doc = "< Other reason."]
pub const cy_wcm_reason_code_CY_WCM_REASON_SUP_OTHER: cy_wcm_reason_code = 512;
#[doc = "< Decryption of key data failed."]
pub const cy_wcm_reason_code_CY_WCM_REASON_SUP_DECRYPT_KEY_DATA: cy_wcm_reason_code = 513;
#[doc = "< Illegal use of ucast WEP-128."]
pub const cy_wcm_reason_code_CY_WCM_REASON_SUP_BAD_UCAST_WEP128: cy_wcm_reason_code = 514;
#[doc = "< Illegal use of ucast WEP-40."]
pub const cy_wcm_reason_code_CY_WCM_REASON_SUP_BAD_UCAST_WEP40: cy_wcm_reason_code = 515;
#[doc = "< Unsupported key length."]
pub const cy_wcm_reason_code_CY_WCM_REASON_SUP_UNSUP_KEY_LEN: cy_wcm_reason_code = 516;
#[doc = "< Unicast cipher mismatch in pairwise key."]
pub const cy_wcm_reason_code_CY_WCM_REASON_SUP_PW_KEY_CIPHER: cy_wcm_reason_code = 517;
#[doc = "< WPA IE contains > 1 RSN IE in key message 3."]
pub const cy_wcm_reason_code_CY_WCM_REASON_SUP_MSG3_TOO_MANY_IE: cy_wcm_reason_code = 518;
#[doc = "< WPA IE mismatch in key message 3."]
pub const cy_wcm_reason_code_CY_WCM_REASON_SUP_MSG3_IE_MISMATCH: cy_wcm_reason_code = 519;
#[doc = "< INSTALL flag unset in 4-way message."]
pub const cy_wcm_reason_code_CY_WCM_REASON_SUP_NO_INSTALL_FLAG: cy_wcm_reason_code = 520;
#[doc = "< Encapsulated GTK missing from message 3."]
pub const cy_wcm_reason_code_CY_WCM_REASON_SUP_MSG3_NO_GTK: cy_wcm_reason_code = 521;
#[doc = "< Multicast cipher mismatch in group key."]
pub const cy_wcm_reason_code_CY_WCM_REASON_SUP_GRP_KEY_CIPHER: cy_wcm_reason_code = 522;
#[doc = "< Encapsulated GTK missing from group message 1."]
pub const cy_wcm_reason_code_CY_WCM_REASON_SUP_GRP_MSG1_NO_GTK: cy_wcm_reason_code = 523;
#[doc = "< GTK decrypt failure."]
pub const cy_wcm_reason_code_CY_WCM_REASON_SUP_GTK_DECRYPT_FAIL: cy_wcm_reason_code = 524;
#[doc = "< Message send failure."]
pub const cy_wcm_reason_code_CY_WCM_REASON_SUP_SEND_FAIL: cy_wcm_reason_code = 525;
#[doc = "< Received FC_DEAUTH."]
pub const cy_wcm_reason_code_CY_WCM_REASON_SUP_DEAUTH: cy_wcm_reason_code = 526;
#[doc = "< WPA PSK 4-way handshake timeout."]
pub const cy_wcm_reason_code_CY_WCM_REASON_SUP_WPA_PSK_TMO: cy_wcm_reason_code = 527;
#[doc = "< d11 RC reserved."]
pub const cy_wcm_reason_code_CY_WCM_DOT11_RC_RESERVED: cy_wcm_reason_code = 768;
#[doc = "< Unspecified reason."]
pub const cy_wcm_reason_code_CY_WCM_DOT11_RC_UNSPECIFIED: cy_wcm_reason_code = 769;
#[doc = "< Previous authentication no longer valid."]
pub const cy_wcm_reason_code_CY_WCM_DOT11_RC_AUTH_INVAL: cy_wcm_reason_code = 770;
#[doc = "< De-authenticated because sending station is leaving (or has left) IBSS or ESS."]
pub const cy_wcm_reason_code_CY_WCM_DOT11_RC_DEAUTH_LEAVING: cy_wcm_reason_code = 771;
#[doc = "< Disassociated due to inactivity."]
pub const cy_wcm_reason_code_CY_WCM_DOT11_RC_INACTIVITY: cy_wcm_reason_code = 772;
#[doc = "< Disassociated because AP is unable to handle all currently associated stations."]
pub const cy_wcm_reason_code_CY_WCM_DOT11_RC_BUSY: cy_wcm_reason_code = 773;
#[doc = "< Class 2 frame received from non-authenticated station."]
pub const cy_wcm_reason_code_CY_WCM_DOT11_RC_INVAL_CLASS_2: cy_wcm_reason_code = 774;
#[doc = "< Class 3 frame received from non-associated station."]
pub const cy_wcm_reason_code_CY_WCM_DOT11_RC_INVAL_CLASS_3: cy_wcm_reason_code = 775;
#[doc = "< Disassociated because sending station is leaving (or has left) BSS."]
pub const cy_wcm_reason_code_CY_WCM_DOT11_RC_DISASSOC_LEAVING: cy_wcm_reason_code = 776;
#[doc = "< Station requesting (re)association is not * authenticated with responding station."]
pub const cy_wcm_reason_code_CY_WCM_DOT11_RC_NOT_AUTH: cy_wcm_reason_code = 777;
#[doc = "< Unacceptable power capability element."]
pub const cy_wcm_reason_code_CY_WCM_DOT11_RC_BAD_PC: cy_wcm_reason_code = 778;
#[doc = "< Unacceptable supported channels element."]
pub const cy_wcm_reason_code_CY_WCM_DOT11_RC_BAD_CHANNELS: cy_wcm_reason_code = 779;
#[doc = "< Unspecified QoS-related reason."]
pub const cy_wcm_reason_code_CY_WCM_DOT11_RC_UNSPECIFIED_QOS: cy_wcm_reason_code = 800;
#[doc = "< QAP lacks sufficient bandwidth."]
pub const cy_wcm_reason_code_CY_WCM_DOT11_RC_INSUFFCIENT_BW: cy_wcm_reason_code = 801;
#[doc = "< Excessive number of frames need ack."]
pub const cy_wcm_reason_code_CY_WCM_DOT11_RC_EXCESSIVE_FRAMES: cy_wcm_reason_code = 802;
#[doc = "< Transmitting outside the limits of txop."]
pub const cy_wcm_reason_code_CY_WCM_DOT11_RC_TX_OUTSIDE_TXOP: cy_wcm_reason_code = 803;
#[doc = "< QSTA is leaving the QBSS (or restting)."]
pub const cy_wcm_reason_code_CY_WCM_DOT11_RC_LEAVING_QBSS: cy_wcm_reason_code = 804;
#[doc = "< Does not want to use the mechanism."]
pub const cy_wcm_reason_code_CY_WCM_DOT11_RC_BAD_MECHANISM: cy_wcm_reason_code = 805;
#[doc = "< Mechanism needs a setup."]
pub const cy_wcm_reason_code_CY_WCM_DOT11_RC_SETUP_NEEDED: cy_wcm_reason_code = 806;
#[doc = "< Timeout."]
pub const cy_wcm_reason_code_CY_WCM_DOT11_RC_TIMEOUT: cy_wcm_reason_code = 807;
#[doc = "< Reason codes > 23 are reserved."]
pub const cy_wcm_reason_code_CY_WCM_DOT11_RC_MAX: cy_wcm_reason_code = 808;
#[doc = "< Force enum to be stored in a 32-bit variable."]
pub const cy_wcm_reason_code_CY_WCM_REASON_FORCE_32_BIT: cy_wcm_reason_code = 2147483646;
#[doc = " Reason codes for disconnection based on WHD enums"]
pub type cy_wcm_reason_code = u32;
#[doc = "< Denotes IPv4 version."]
pub const cy_wcm_ip_version_t_CY_WCM_IP_VER_V4: cy_wcm_ip_version_t = 4;
#[doc = "< Denotes IPv6 version."]
pub const cy_wcm_ip_version_t_CY_WCM_IP_VER_V6: cy_wcm_ip_version_t = 6;
#[doc = " IP Version"]
pub type cy_wcm_ip_version_t = u32;
#[doc = "< Denotes IPv6 link-local address type."]
pub const cy_wcm_ipv6_type_t_CY_WCM_IPV6_LINK_LOCAL: cy_wcm_ipv6_type_t = 0;
#[doc = "< Denotes IPv6 global address type."]
pub const cy_wcm_ipv6_type_t_CY_WCM_IPV6_GLOBAL: cy_wcm_ipv6_type_t = 1;
#[doc = " IPV6 types"]
pub type cy_wcm_ipv6_type_t = u32;
#[doc = "< Open security."]
pub const cy_wcm_security_t_CY_WCM_SECURITY_OPEN: cy_wcm_security_t = 0;
#[doc = "< WEP PSK security with open authentication."]
pub const cy_wcm_security_t_CY_WCM_SECURITY_WEP_PSK: cy_wcm_security_t = 1;
#[doc = "< WEP PSK security with shared authentication."]
pub const cy_wcm_security_t_CY_WCM_SECURITY_WEP_SHARED: cy_wcm_security_t = 32769;
#[doc = "< WPA PSK security with TKIP."]
pub const cy_wcm_security_t_CY_WCM_SECURITY_WPA_TKIP_PSK: cy_wcm_security_t = 2097154;
#[doc = "< WPA PSK security with AES."]
pub const cy_wcm_security_t_CY_WCM_SECURITY_WPA_AES_PSK: cy_wcm_security_t = 2097156;
#[doc = "< WPA PSK security with AES and TKIP."]
pub const cy_wcm_security_t_CY_WCM_SECURITY_WPA_MIXED_PSK: cy_wcm_security_t = 2097158;
#[doc = "< WPA2 PSK security with AES."]
pub const cy_wcm_security_t_CY_WCM_SECURITY_WPA2_AES_PSK: cy_wcm_security_t = 4194308;
#[doc = "< WPA2 PSK SHA256 Security with AES"]
pub const cy_wcm_security_t_CY_WCM_SECURITY_WPA2_AES_PSK_SHA256: cy_wcm_security_t = 12582916;
#[doc = "< WPA2 PSK security with TKIP."]
pub const cy_wcm_security_t_CY_WCM_SECURITY_WPA2_TKIP_PSK: cy_wcm_security_t = 4194306;
#[doc = "< WPA2 PSK security with AES and TKIP."]
pub const cy_wcm_security_t_CY_WCM_SECURITY_WPA2_MIXED_PSK: cy_wcm_security_t = 4194310;
#[doc = "< WPA2 FBT PSK security with AES and TKIP."]
pub const cy_wcm_security_t_CY_WCM_SECURITY_WPA2_FBT_PSK: cy_wcm_security_t = 1077936132;
#[doc = "< WPA3 security with AES."]
pub const cy_wcm_security_t_CY_WCM_SECURITY_WPA3_SAE: cy_wcm_security_t = 16777220;
#[doc = "< WPA2 WPA PSK Security with AES"]
pub const cy_wcm_security_t_CY_WCM_SECURITY_WPA2_WPA_AES_PSK: cy_wcm_security_t = 6291460;
#[doc = "< WPA2 WPA PSK Security with AES & TKIP."]
pub const cy_wcm_security_t_CY_WCM_SECURITY_WPA2_WPA_MIXED_PSK: cy_wcm_security_t = 6291462;
#[doc = "< WPA3 WPA2 PSK security with AES."]
pub const cy_wcm_security_t_CY_WCM_SECURITY_WPA3_WPA2_PSK: cy_wcm_security_t = 20971524;
#[doc = "< WPA Enterprise Security with TKIP."]
pub const cy_wcm_security_t_CY_WCM_SECURITY_WPA_TKIP_ENT: cy_wcm_security_t = 35651586;
#[doc = "< WPA Enterprise Security with AES"]
pub const cy_wcm_security_t_CY_WCM_SECURITY_WPA_AES_ENT: cy_wcm_security_t = 35651588;
#[doc = "< WPA Enterprise Security with AES and TKIP."]
pub const cy_wcm_security_t_CY_WCM_SECURITY_WPA_MIXED_ENT: cy_wcm_security_t = 35651590;
#[doc = "< WPA2 Enterprise Security with TKIP."]
pub const cy_wcm_security_t_CY_WCM_SECURITY_WPA2_TKIP_ENT: cy_wcm_security_t = 37748738;
#[doc = "< WPA2 Enterprise Security with AES."]
pub const cy_wcm_security_t_CY_WCM_SECURITY_WPA2_AES_ENT: cy_wcm_security_t = 37748740;
#[doc = "< WPA2 Enterprise Security with AES and TKIP."]
pub const cy_wcm_security_t_CY_WCM_SECURITY_WPA2_MIXED_ENT: cy_wcm_security_t = 37748742;
#[doc = "< WPA2 Enterprise Security with AES and FBT."]
pub const cy_wcm_security_t_CY_WCM_SECURITY_WPA2_FBT_ENT: cy_wcm_security_t = 1111490564;
#[doc = "< Open security on IBSS ad hoc network."]
pub const cy_wcm_security_t_CY_WCM_SECURITY_IBSS_OPEN: cy_wcm_security_t = 536870912;
#[doc = "< WPS with AES security."]
pub const cy_wcm_security_t_CY_WCM_SECURITY_WPS_SECURE: cy_wcm_security_t = 268435460;
#[doc = "< Returned by \\ref cy_wcm_scan_result_callback_t if security is unknown. Do not pass this to the join function!"]
pub const cy_wcm_security_t_CY_WCM_SECURITY_UNKNOWN: cy_wcm_security_t = -1;
#[doc = "< Exists only to force whd_security_t type to 32 bits."]
pub const cy_wcm_security_t_CY_WCM_SECURITY_FORCE_32_BIT: cy_wcm_security_t = 2147483647;
#[doc = " Enumeration of Wi-Fi Security Modes"]
pub type cy_wcm_security_t = i32;
#[doc = "< Platform will choose an available band."]
pub const cy_wcm_wifi_band_t_CY_WCM_WIFI_BAND_ANY: cy_wcm_wifi_band_t = 0;
#[doc = "< 5-GHz radio band."]
pub const cy_wcm_wifi_band_t_CY_WCM_WIFI_BAND_5GHZ: cy_wcm_wifi_band_t = 1;
#[doc = "< 2.4-GHz radio band."]
pub const cy_wcm_wifi_band_t_CY_WCM_WIFI_BAND_2_4GHZ: cy_wcm_wifi_band_t = 2;
#[doc = " Enumeration of 802.11 radio bands"]
pub type cy_wcm_wifi_band_t = u32;
#[doc = "< Wi-Fi RSSI values greater than -90 dBm."]
pub const cy_wcm_scan_rssi_range_t_CY_WCM_SCAN_RSSI_FAIR: cy_wcm_scan_rssi_range_t = -90;
#[doc = "< Wi-Fi RSSI values greater than -60 dBm."]
pub const cy_wcm_scan_rssi_range_t_CY_WCM_SCAN_RSSI_GOOD: cy_wcm_scan_rssi_range_t = -60;
#[doc = "< Wi-Fi RSSI values greater than -40 dBm."]
pub const cy_wcm_scan_rssi_range_t_CY_WCM_SCAN_RSSI_EXCELLENT: cy_wcm_scan_rssi_range_t = -40;
#[doc = " Enumeration of RSSI range"]
pub type cy_wcm_scan_rssi_range_t = i32;
#[doc = "< STA or client interface."]
pub const cy_wcm_interface_t_CY_WCM_INTERFACE_TYPE_STA: cy_wcm_interface_t = 0;
#[doc = "< SoftAP interface."]
pub const cy_wcm_interface_t_CY_WCM_INTERFACE_TYPE_AP: cy_wcm_interface_t = 1;
#[doc = "< Concurrent AP + STA mode."]
pub const cy_wcm_interface_t_CY_WCM_INTERFACE_TYPE_AP_STA: cy_wcm_interface_t = 2;
#[doc = " Enumeration of WCM interfaces types"]
pub type cy_wcm_interface_t = u32;
#[doc = "< No power savings"]
pub const cy_wcm_powersave_mode_t_CY_WCM_NO_POWERSAVE_MODE: cy_wcm_powersave_mode_t = 0;
#[doc = "< Powersave mode on specified interface without regard for throughput reduction"]
pub const cy_wcm_powersave_mode_t_CY_WCM_PM1_POWERSAVE_MODE: cy_wcm_powersave_mode_t = 1;
#[doc = "< Powersave mode on specified interface with High throughput"]
pub const cy_wcm_powersave_mode_t_CY_WCM_PM2_POWERSAVE_MODE: cy_wcm_powersave_mode_t = 2;
#[doc = " Enumeration of WCM Powersave Modes"]
pub type cy_wcm_powersave_mode_t = u32;
#[doc = "< Scan is in progress; more scan results will be returned."]
pub const cy_wcm_scan_status_t_CY_WCM_SCAN_INCOMPLETE: cy_wcm_scan_status_t = 0;
#[doc = "< Scan is completed."]
pub const cy_wcm_scan_status_t_CY_WCM_SCAN_COMPLETE: cy_wcm_scan_status_t = 1;
#[doc = " Enumeration of scan status"]
pub type cy_wcm_scan_status_t = u32;
#[doc = "< Push button mode."]
pub const cy_wcm_wps_mode_t_CY_WCM_WPS_PBC_MODE: cy_wcm_wps_mode_t = 0;
#[doc = "< PIN mode."]
pub const cy_wcm_wps_mode_t_CY_WCM_WPS_PIN_MODE: cy_wcm_wps_mode_t = 1;
#[doc = " Enumeration of WPS connection modes"]
pub type cy_wcm_wps_mode_t = u32;
#[doc = "< USB configuration."]
pub const cy_wcm_wps_configuration_method_t_CY_WCM_WPS_CONFIG_USBA:
    cy_wcm_wps_configuration_method_t = 1;
#[doc = "< Ethernet configuration."]
pub const cy_wcm_wps_configuration_method_t_CY_WCM_WPS_CONFIG_ETHERNET:
    cy_wcm_wps_configuration_method_t = 2;
#[doc = "< Label configuration."]
pub const cy_wcm_wps_configuration_method_t_CY_WCM_WPS_CONFIG_LABEL:
    cy_wcm_wps_configuration_method_t = 4;
#[doc = "< Display configuration."]
pub const cy_wcm_wps_configuration_method_t_CY_WCM_WPS_CONFIG_DISPLAY:
    cy_wcm_wps_configuration_method_t = 8;
#[doc = "< External NFC configuration."]
pub const cy_wcm_wps_configuration_method_t_CY_WCM_WPS_CONFIG_EXTERNAL_NFC_TOKEN:
    cy_wcm_wps_configuration_method_t = 16;
#[doc = "< Internal NFC configuration."]
pub const cy_wcm_wps_configuration_method_t_CY_WCM_WPS_CONFIG_INTEGRATED_NFC_TOKEN:
    cy_wcm_wps_configuration_method_t = 32;
#[doc = "< NFC interface."]
pub const cy_wcm_wps_configuration_method_t_CY_WCM_WPS_CONFIG_NFC_INTERFACE:
    cy_wcm_wps_configuration_method_t = 64;
#[doc = "< Push button configuration."]
pub const cy_wcm_wps_configuration_method_t_CY_WCM_WPS_CONFIG_PUSH_BUTTON:
    cy_wcm_wps_configuration_method_t = 128;
#[doc = "< Keypad configuration."]
pub const cy_wcm_wps_configuration_method_t_CY_WCM_WPS_CONFIG_KEYPAD:
    cy_wcm_wps_configuration_method_t = 256;
#[doc = "< Virtual push button configuration."]
pub const cy_wcm_wps_configuration_method_t_CY_WCM_WPS_CONFIG_VIRTUAL_PUSH_BUTTON:
    cy_wcm_wps_configuration_method_t = 640;
#[doc = "< Physical push button configuration."]
pub const cy_wcm_wps_configuration_method_t_CY_WCM_WPS_CONFIG_PHYSICAL_PUSH_BUTTON:
    cy_wcm_wps_configuration_method_t = 1152;
#[doc = "< Virtual display pin configuration."]
pub const cy_wcm_wps_configuration_method_t_CY_WCM_WPS_CONFIG_VIRTUAL_DISPLAY_PIN:
    cy_wcm_wps_configuration_method_t = 8200;
#[doc = "< Physical display pin configuration."]
pub const cy_wcm_wps_configuration_method_t_CY_WCM_WPS_CONFIG_PHYSICAL_DISPLAY_PIN:
    cy_wcm_wps_configuration_method_t = 16392;
#[doc = " Enumeration of WPS configuration method"]
pub type cy_wcm_wps_configuration_method_t = u32;
#[doc = "< Authentication type OPEN."]
pub const cy_wcm_wps_authentication_type_t_CY_WCM_WPS_OPEN_AUTHENTICATION:
    cy_wcm_wps_authentication_type_t = 1;
#[doc = "< WPA-PSK authentication type - Deprecated in version 2.0."]
pub const cy_wcm_wps_authentication_type_t_CY_WCM_WPS_WPA_PSK_AUTHENTICATION:
    cy_wcm_wps_authentication_type_t = 2;
#[doc = "< WPS-SHARED authentication type - Deprecated in version 2.0."]
pub const cy_wcm_wps_authentication_type_t_CY_WCM_WPS_SHARED_AUTHENTICATION:
    cy_wcm_wps_authentication_type_t = 4;
#[doc = "< WPA-ENTERPRISE authentication type - Deprecated in version 2.0."]
pub const cy_wcm_wps_authentication_type_t_CY_WCM_WPS_WPA_ENTERPRISE_AUTHENTICATION:
    cy_wcm_wps_authentication_type_t = 8;
#[doc = "< WPA2-ENTERPRISE authentication type."]
pub const cy_wcm_wps_authentication_type_t_CY_WCM_WPS_WPA2_ENTERPRISE_AUTHENTICATION:
    cy_wcm_wps_authentication_type_t = 16;
#[doc = "< WPA2-PSK authentication type."]
pub const cy_wcm_wps_authentication_type_t_CY_WCM_WPS_WPA2_PSK_AUTHENTICATION:
    cy_wcm_wps_authentication_type_t = 32;
#[doc = "< WPA2-WPA-PSK authentication type."]
pub const cy_wcm_wps_authentication_type_t_CY_WCM_WPS_WPA2_WPA_PSK_MIXED_AUTHENTICATION:
    cy_wcm_wps_authentication_type_t = 34;
#[doc = " Enumeration of WPS authentication types"]
pub type cy_wcm_wps_authentication_type_t = u32;
#[doc = "< MIXED encryption."]
pub const cy_wcm_wps_encryption_type_t_CY_WCM_WPS_MIXED_ENCRYPTION: cy_wcm_wps_encryption_type_t =
    12;
#[doc = "< AES encryption."]
pub const cy_wcm_wps_encryption_type_t_CY_WCM_WPS_AES_ENCRYPTION: cy_wcm_wps_encryption_type_t = 8;
#[doc = "< TKIP encryption - Deprecated in WSC 2.0."]
pub const cy_wcm_wps_encryption_type_t_CY_WCM_WPS_TKIP_ENCRYPTION: cy_wcm_wps_encryption_type_t = 4;
#[doc = "< WEP encryption - Deprecated in WSC 2.0."]
pub const cy_wcm_wps_encryption_type_t_CY_WCM_WPS_WEP_ENCRYPTION: cy_wcm_wps_encryption_type_t = 2;
#[doc = "< OPEN - No encryption."]
pub const cy_wcm_wps_encryption_type_t_CY_WCM_WPS_NO_ENCRYPTION: cy_wcm_wps_encryption_type_t = 1;
#[doc = "< Undefined encryption type."]
pub const cy_wcm_wps_encryption_type_t_CY_WCM_WPS_NO_UNDEFINED: cy_wcm_wps_encryption_type_t = 0;
#[doc = " Enumeration of WPS encryption type"]
pub type cy_wcm_wps_encryption_type_t = u32;
#[doc = "< Computer devices."]
pub const cy_wcm_wps_device_category_t_CY_WCM_WPS_DEVICE_COMPUTER: cy_wcm_wps_device_category_t = 1;
#[doc = "< Input devices."]
pub const cy_wcm_wps_device_category_t_CY_WCM_WPS_DEVICE_INPUT: cy_wcm_wps_device_category_t = 2;
#[doc = "< Devices such as printers, scanners, faxes and copiers."]
pub const cy_wcm_wps_device_category_t_CY_WCM_WPS_DEVICE_PRINT_SCAN_FAX_COPY:
    cy_wcm_wps_device_category_t = 3;
#[doc = "< Camera devices."]
pub const cy_wcm_wps_device_category_t_CY_WCM_WPS_DEVICE_CAMERA: cy_wcm_wps_device_category_t = 4;
#[doc = "< Storage devices."]
pub const cy_wcm_wps_device_category_t_CY_WCM_WPS_DEVICE_STORAGE: cy_wcm_wps_device_category_t = 5;
#[doc = "< Network infrastructure devices."]
pub const cy_wcm_wps_device_category_t_CY_WCM_WPS_DEVICE_NETWORK_INFRASTRUCTURE:
    cy_wcm_wps_device_category_t = 6;
#[doc = "< Display devices."]
pub const cy_wcm_wps_device_category_t_CY_WCM_WPS_DEVICE_DISPLAY: cy_wcm_wps_device_category_t = 7;
#[doc = "< Multimedia devices."]
pub const cy_wcm_wps_device_category_t_CY_WCM_WPS_DEVICE_MULTIMEDIA: cy_wcm_wps_device_category_t =
    8;
#[doc = "< Gaming devices."]
pub const cy_wcm_wps_device_category_t_CY_WCM_WPS_DEVICE_GAMING: cy_wcm_wps_device_category_t = 9;
#[doc = "< Telephony devices."]
pub const cy_wcm_wps_device_category_t_CY_WCM_WPS_DEVICE_TELEPHONE: cy_wcm_wps_device_category_t =
    10;
#[doc = "< Audio devices."]
pub const cy_wcm_wps_device_category_t_CY_WCM_WPS_DEVICE_AUDIO: cy_wcm_wps_device_category_t = 11;
#[doc = "< Docking devices."]
pub const cy_wcm_wps_device_category_t_CY_WCM_WPS_DEVICE_DOCK: cy_wcm_wps_device_category_t = 12;
#[doc = "< Other devices."]
pub const cy_wcm_wps_device_category_t_CY_WCM_WPS_DEVICE_OTHER: cy_wcm_wps_device_category_t = 255;
#[doc = " Enumeration of WPS device category from the WSC 2.0 spec"]
pub type cy_wcm_wps_device_category_t = u32;
#[doc = "< STA connecting to an AP."]
pub const cy_wcm_event_t_CY_WCM_EVENT_CONNECTING: cy_wcm_event_t = 0;
#[doc = "< STA connected to the AP."]
pub const cy_wcm_event_t_CY_WCM_EVENT_CONNECTED: cy_wcm_event_t = 1;
#[doc = "< STA connection to the AP failed."]
pub const cy_wcm_event_t_CY_WCM_EVENT_CONNECT_FAILED: cy_wcm_event_t = 2;
#[doc = "< STA reconnected to the AP."]
pub const cy_wcm_event_t_CY_WCM_EVENT_RECONNECTED: cy_wcm_event_t = 3;
#[doc = "< STA disconnected from the AP."]
pub const cy_wcm_event_t_CY_WCM_EVENT_DISCONNECTED: cy_wcm_event_t = 4;
#[doc = "< IP address change event. This event is notified after connection, re-connection, and IP address change due to DHCP renewal."]
pub const cy_wcm_event_t_CY_WCM_EVENT_IP_CHANGED: cy_wcm_event_t = 5;
#[doc = "< Indicates that WCM will initiate a retry logic to re-connect to the AP"]
pub const cy_wcm_event_t_CY_WCM_EVENT_INITIATED_RETRY: cy_wcm_event_t = 6;
#[doc = "< An STA device connected to SoftAP."]
pub const cy_wcm_event_t_CY_WCM_EVENT_STA_JOINED_SOFTAP: cy_wcm_event_t = 7;
#[doc = "< An STA device disconnected from SoftAP."]
pub const cy_wcm_event_t_CY_WCM_EVENT_STA_LEFT_SOFTAP: cy_wcm_event_t = 8;
#[doc = " Enumeration of WCM events"]
pub type cy_wcm_event_t = u32;
#[doc = "< SSID-based scan filtering."]
pub const cy_wcm_scan_filter_type_t_CY_WCM_SCAN_FILTER_TYPE_SSID: cy_wcm_scan_filter_type_t = 0;
#[doc = "< MAC-based scan filtering."]
pub const cy_wcm_scan_filter_type_t_CY_WCM_SCAN_FILTER_TYPE_MAC: cy_wcm_scan_filter_type_t = 1;
#[doc = "< Band-based scan filtering."]
pub const cy_wcm_scan_filter_type_t_CY_WCM_SCAN_FILTER_TYPE_BAND: cy_wcm_scan_filter_type_t = 2;
#[doc = "< RSSI-based scan filtering."]
pub const cy_wcm_scan_filter_type_t_CY_WCM_SCAN_FILTER_TYPE_RSSI: cy_wcm_scan_filter_type_t = 3;
#[doc = " Enumeration of scan filter types"]
pub type cy_wcm_scan_filter_type_t = u32;
#[doc = "< Infrastructure network."]
pub const cy_wcm_bss_type_t_CY_WCM_BSS_TYPE_INFRASTRUCTURE: cy_wcm_bss_type_t = 0;
#[doc = "< 802.11 ad hoc IBSS network."]
pub const cy_wcm_bss_type_t_CY_WCM_BSS_TYPE_ADHOC: cy_wcm_bss_type_t = 1;
#[doc = "< Either infrastructure or ad hoc network."]
pub const cy_wcm_bss_type_t_CY_WCM_BSS_TYPE_ANY: cy_wcm_bss_type_t = 2;
#[doc = "< 802.11 mesh network."]
pub const cy_wcm_bss_type_t_CY_WCM_BSS_TYPE_MESH: cy_wcm_bss_type_t = 3;
#[doc = "< Returned by \\ref cy_wcm_scan_result_callback_t if BSS type is unknown. Do not pass this to the Join function."]
pub const cy_wcm_bss_type_t_CY_WCM_BSS_TYPE_UNKNOWN: cy_wcm_bss_type_t = -1;
#[doc = " Enumeration of network types"]
pub type cy_wcm_bss_type_t = i32;
#[doc = "< Denotes mask for beacon packet."]
pub const cy_wcm_ie_mask_t_CY_WCM_IE_MASK_BEACON: cy_wcm_ie_mask_t = 1;
#[doc = "< Denotes mask for probe response packet."]
pub const cy_wcm_ie_mask_t_CY_WCM_IE_MASK_PROBE_RESPONSE: cy_wcm_ie_mask_t = 2;
#[doc = "< Denotes mask for association response packet."]
pub const cy_wcm_ie_mask_t_CY_WCM_IE_MASK_ASSOC_RESPONSE: cy_wcm_ie_mask_t = 4;
#[doc = "< Denotes mask for authentication response packet."]
pub const cy_wcm_ie_mask_t_CY_WCM_IE_MASK_AUTH_RESPONSE: cy_wcm_ie_mask_t = 8;
#[doc = "< Denotes mask for probe request packet."]
pub const cy_wcm_ie_mask_t_CY_WCM_IE_MASK_PROBE_REQUEST: cy_wcm_ie_mask_t = 16;
#[doc = "< Denotes mask for association request packet."]
pub const cy_wcm_ie_mask_t_CY_WCM_IE_MASK_ASSOC_REQUEST: cy_wcm_ie_mask_t = 32;
#[doc = "< Denotes mask for custom IE identifier."]
pub const cy_wcm_ie_mask_t_CY_WCM_IE_MASK_CUSTOM: cy_wcm_ie_mask_t = 256;
#[doc = " Enumeration of applicable packet mask bits for custom information elements (IEs)"]
pub type cy_wcm_ie_mask_t = u32;
#[doc = " \\addtogroup group_wcm_typedefs\n \\{\n/\n/******************************************************\n                      Typedefs"]
pub type cy_wcm_ssid_t = [u8; 33usize];
pub type cy_wcm_mac_t = [u8; 6usize];
pub type cy_wcm_passphrase_t = [u8; 64usize];
#[doc = " Structure used to pass WPS configuration parameters to \\ref cy_wcm_wps_enrollee.\n Password is mandatory only for CY_WCM_WPS_PIN mode and not used when mode is CY_WCM_WPS_PBC."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cy_wcm_wps_config_t {
    #[doc = "< WPS mode."]
    pub mode: cy_wcm_wps_mode_t,
    #[doc = "< Used only for CY_WCM_WPS_PIN mode."]
    pub password: *mut ::core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_cy_wcm_wps_config_t() {
    const UNINIT: ::core::mem::MaybeUninit<cy_wcm_wps_config_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cy_wcm_wps_config_t>(),
        16usize,
        concat!("Size of: ", stringify!(cy_wcm_wps_config_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cy_wcm_wps_config_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cy_wcm_wps_config_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_wps_config_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).password) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_wps_config_t),
            "::",
            stringify!(password)
        )
    );
}
#[doc = " Structure used to pass WCM configuration to \\ref cy_wcm_init."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cy_wcm_config_t {
    #[doc = "< Interface type."]
    pub interface: cy_wcm_interface_t,
}
#[test]
fn bindgen_test_layout_cy_wcm_config_t() {
    const UNINIT: ::core::mem::MaybeUninit<cy_wcm_config_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cy_wcm_config_t>(),
        4usize,
        concat!("Size of: ", stringify!(cy_wcm_config_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cy_wcm_config_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cy_wcm_config_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).interface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_config_t),
            "::",
            stringify!(interface)
        )
    );
}
#[doc = " Structure used to receive the IP address information from \\ref cy_wcm_connect_ap."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cy_wcm_ip_address_t {
    #[doc = "< IP version."]
    pub version: cy_wcm_ip_version_t,
    #[doc = "< IP address bytes."]
    pub ip: cy_wcm_ip_address_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cy_wcm_ip_address_t__bindgen_ty_1 {
    #[doc = "< IPv4 address in network byte order."]
    pub v4: u32,
    #[doc = "< IPv6 address in network byte order."]
    pub v6: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_cy_wcm_ip_address_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<cy_wcm_ip_address_t__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cy_wcm_ip_address_t__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(cy_wcm_ip_address_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<cy_wcm_ip_address_t__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cy_wcm_ip_address_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v4) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_ip_address_t__bindgen_ty_1),
            "::",
            stringify!(v4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v6) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_ip_address_t__bindgen_ty_1),
            "::",
            stringify!(v6)
        )
    );
}
#[test]
fn bindgen_test_layout_cy_wcm_ip_address_t() {
    const UNINIT: ::core::mem::MaybeUninit<cy_wcm_ip_address_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cy_wcm_ip_address_t>(),
        20usize,
        concat!("Size of: ", stringify!(cy_wcm_ip_address_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cy_wcm_ip_address_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cy_wcm_ip_address_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_ip_address_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_ip_address_t),
            "::",
            stringify!(ip)
        )
    );
}
#[doc = " Structure used to receive the IP address of the STA or MAC address of the connected STA to SoftAP through the callback registered using \\ref cy_wcm_register_event_callback."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union cy_wcm_event_data_t {
    #[doc = "< Contains the IP address for the CY_WCM_EVENT_IP_CHANGED event."]
    pub ip_addr: cy_wcm_ip_address_t,
    #[doc = "< MAC address of the STA for the CY_WCM_EVENT_STA_JOINED or CY_WCM_EVENT_STA_LEFT"]
    pub sta_mac: cy_wcm_mac_t,
    #[doc = "< Reason code which specifies the reason for disconnection."]
    pub reason: cy_wcm_reason_code,
}
#[test]
fn bindgen_test_layout_cy_wcm_event_data_t() {
    const UNINIT: ::core::mem::MaybeUninit<cy_wcm_event_data_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cy_wcm_event_data_t>(),
        20usize,
        concat!("Size of: ", stringify!(cy_wcm_event_data_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cy_wcm_event_data_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cy_wcm_event_data_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_event_data_t),
            "::",
            stringify!(ip_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sta_mac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_event_data_t),
            "::",
            stringify!(sta_mac)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reason) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_event_data_t),
            "::",
            stringify!(reason)
        )
    );
}
#[doc = " Structure used for providing the AP credential to connect to a AP using \\ref cy_wcm_connect_ap."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cy_wcm_ap_credentials_t {
    #[doc = "< SSID of the Wi-Fi network to join; should be a null-terminated string."]
    pub SSID: cy_wcm_ssid_t,
    #[doc = "< Password needed to join the AP; should be a null-terminated string."]
    pub password: cy_wcm_passphrase_t,
    #[doc = "< Wi-Fi Security. @see cy_wcm_security_t."]
    pub security: cy_wcm_security_t,
}
#[test]
fn bindgen_test_layout_cy_wcm_ap_credentials_t() {
    const UNINIT: ::core::mem::MaybeUninit<cy_wcm_ap_credentials_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cy_wcm_ap_credentials_t>(),
        104usize,
        concat!("Size of: ", stringify!(cy_wcm_ap_credentials_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cy_wcm_ap_credentials_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cy_wcm_ap_credentials_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SSID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_ap_credentials_t),
            "::",
            stringify!(SSID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).password) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_ap_credentials_t),
            "::",
            stringify!(password)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).security) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_ap_credentials_t),
            "::",
            stringify!(security)
        )
    );
}
#[doc = " Structure used to pass the static IP address information to \\ref cy_wcm_connect_ap.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cy_wcm_ip_setting_t {
    #[doc = "< IP address."]
    pub ip_address: cy_wcm_ip_address_t,
    #[doc = "< Gateway address."]
    pub gateway: cy_wcm_ip_address_t,
    #[doc = "< Netmask."]
    pub netmask: cy_wcm_ip_address_t,
}
#[test]
fn bindgen_test_layout_cy_wcm_ip_setting_t() {
    const UNINIT: ::core::mem::MaybeUninit<cy_wcm_ip_setting_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cy_wcm_ip_setting_t>(),
        60usize,
        concat!("Size of: ", stringify!(cy_wcm_ip_setting_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cy_wcm_ip_setting_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cy_wcm_ip_setting_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_ip_setting_t),
            "::",
            stringify!(ip_address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gateway) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_ip_setting_t),
            "::",
            stringify!(gateway)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).netmask) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_ip_setting_t),
            "::",
            stringify!(netmask)
        )
    );
}
#[doc = " Structure used to pass the Wi-Fi connection parameter information to \\ref cy_wcm_connect_ap.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cy_wcm_connect_params_t {
    #[doc = "< AP credentials."]
    pub ap_credentials: cy_wcm_ap_credentials_t,
    #[doc = "< MAC address of the AP (optional)."]
    pub BSSID: cy_wcm_mac_t,
    #[doc = "< Static IP settings of the device (optional)."]
    pub static_ip_settings: *mut cy_wcm_ip_setting_t,
    #[doc = "< Radio band to be connected (optional)."]
    pub band: cy_wcm_wifi_band_t,
}
#[test]
fn bindgen_test_layout_cy_wcm_connect_params_t() {
    const UNINIT: ::core::mem::MaybeUninit<cy_wcm_connect_params_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cy_wcm_connect_params_t>(),
        128usize,
        concat!("Size of: ", stringify!(cy_wcm_connect_params_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cy_wcm_connect_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cy_wcm_connect_params_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ap_credentials) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_connect_params_t),
            "::",
            stringify!(ap_credentials)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BSSID) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_connect_params_t),
            "::",
            stringify!(BSSID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).static_ip_settings) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_connect_params_t),
            "::",
            stringify!(static_ip_settings)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).band) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_connect_params_t),
            "::",
            stringify!(band)
        )
    );
}
#[doc = " Structure used to pass scan filters to \\ref cy_wcm_start_scan."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cy_wcm_scan_filter_t {
    #[doc = "< Scan filter mode."]
    pub mode: cy_wcm_scan_filter_type_t,
    #[doc = "< Parameter specific to scan filter mode."]
    pub param: cy_wcm_scan_filter_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cy_wcm_scan_filter_t__bindgen_ty_1 {
    #[doc = "< SSID."]
    pub SSID: cy_wcm_ssid_t,
    #[doc = "< MAC address of AP."]
    pub BSSID: cy_wcm_mac_t,
    #[doc = "< Radio band."]
    pub band: cy_wcm_wifi_band_t,
    #[doc = "< RSSI range."]
    pub rssi_range: cy_wcm_scan_rssi_range_t,
}
#[test]
fn bindgen_test_layout_cy_wcm_scan_filter_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<cy_wcm_scan_filter_t__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cy_wcm_scan_filter_t__bindgen_ty_1>(),
        36usize,
        concat!("Size of: ", stringify!(cy_wcm_scan_filter_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<cy_wcm_scan_filter_t__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cy_wcm_scan_filter_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SSID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_scan_filter_t__bindgen_ty_1),
            "::",
            stringify!(SSID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BSSID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_scan_filter_t__bindgen_ty_1),
            "::",
            stringify!(BSSID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).band) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_scan_filter_t__bindgen_ty_1),
            "::",
            stringify!(band)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rssi_range) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_scan_filter_t__bindgen_ty_1),
            "::",
            stringify!(rssi_range)
        )
    );
}
#[test]
fn bindgen_test_layout_cy_wcm_scan_filter_t() {
    const UNINIT: ::core::mem::MaybeUninit<cy_wcm_scan_filter_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cy_wcm_scan_filter_t>(),
        40usize,
        concat!("Size of: ", stringify!(cy_wcm_scan_filter_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cy_wcm_scan_filter_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cy_wcm_scan_filter_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_scan_filter_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).param) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_scan_filter_t),
            "::",
            stringify!(param)
        )
    );
}
#[doc = " Structure used for storing scan results."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cy_wcm_scan_result_t {
    #[doc = "< SSID (i.e., name of the AP). In case of a hidden AP, SSID.value will be empty and SSID.length will be 0."]
    pub SSID: cy_wcm_ssid_t,
    #[doc = "< Basic Service Set Identification (BSSID), i.e., MAC address of the AP."]
    pub BSSID: cy_wcm_mac_t,
    #[doc = "< RSSI in dBm. (<-90=Very poor, >-30=Excellent)."]
    pub signal_strength: i16,
    #[doc = "< Maximum data rate in kbps."]
    pub max_data_rate: u32,
    #[doc = "< Network type."]
    pub bss_type: cy_wcm_bss_type_t,
    #[doc = "< Security type."]
    pub security: cy_wcm_security_t,
    #[doc = "< Radio channel that the AP beacon was received on."]
    pub channel: u8,
    #[doc = "< Radio band."]
    pub band: cy_wcm_wifi_band_t,
    #[doc = "< Two-letter ISO country code in network byte order."]
    pub ccode: [u8; 2usize],
    #[doc = "< Indicates whether the scan results are from the same channel if flag is 1; otherwise from the beacon."]
    pub flags: u8,
    #[doc = "< Pointer to the received Beacon/Probe Response IE (Information Element)."]
    pub ie_ptr: *mut u8,
    #[doc = "< Length of the IE."]
    pub ie_len: u32,
}
#[test]
fn bindgen_test_layout_cy_wcm_scan_result_t() {
    const UNINIT: ::core::mem::MaybeUninit<cy_wcm_scan_result_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cy_wcm_scan_result_t>(),
        88usize,
        concat!("Size of: ", stringify!(cy_wcm_scan_result_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cy_wcm_scan_result_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cy_wcm_scan_result_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SSID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_scan_result_t),
            "::",
            stringify!(SSID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BSSID) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_scan_result_t),
            "::",
            stringify!(BSSID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signal_strength) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_scan_result_t),
            "::",
            stringify!(signal_strength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_data_rate) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_scan_result_t),
            "::",
            stringify!(max_data_rate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bss_type) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_scan_result_t),
            "::",
            stringify!(bss_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).security) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_scan_result_t),
            "::",
            stringify!(security)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).channel) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_scan_result_t),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).band) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_scan_result_t),
            "::",
            stringify!(band)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ccode) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_scan_result_t),
            "::",
            stringify!(ccode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_scan_result_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ie_ptr) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_scan_result_t),
            "::",
            stringify!(ie_ptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ie_len) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_scan_result_t),
            "::",
            stringify!(ie_len)
        )
    );
}
#[doc = " Structure used to pass the device information to \\ref cy_wcm_wps_enrollee."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cy_wcm_wps_device_detail_t {
    #[doc = "< Device category."]
    pub device_category: cy_wcm_wps_device_category_t,
    #[doc = "< Device sub-category."]
    pub sub_category: u16,
    #[doc = "< Device name."]
    pub device_name: *const ::core::ffi::c_char,
    #[doc = "< Manufacturer details."]
    pub manufacturer: *const ::core::ffi::c_char,
    #[doc = "< Model name."]
    pub model_name: *const ::core::ffi::c_char,
    #[doc = "< Model number."]
    pub model_number: *const ::core::ffi::c_char,
    #[doc = "< Serial number."]
    pub serial_number: *const ::core::ffi::c_char,
    #[doc = "< Configuration methods."]
    pub config_methods: u32,
    #[doc = "< Operating system version."]
    pub os_version: u32,
    #[doc = "< Supported authentication types."]
    pub authentication_type_flags: u16,
    #[doc = "< Supported encryption types."]
    pub encryption_type_flags: u16,
    #[doc = "< Add configuration methods to probe response for Windows enrollees (Not compliant with WPS 2.0)."]
    pub add_config_methods_to_probe_resp: u8,
}
#[test]
fn bindgen_test_layout_cy_wcm_wps_device_detail_t() {
    const UNINIT: ::core::mem::MaybeUninit<cy_wcm_wps_device_detail_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cy_wcm_wps_device_detail_t>(),
        64usize,
        concat!("Size of: ", stringify!(cy_wcm_wps_device_detail_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cy_wcm_wps_device_detail_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cy_wcm_wps_device_detail_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).device_category) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_wps_device_detail_t),
            "::",
            stringify!(device_category)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sub_category) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_wps_device_detail_t),
            "::",
            stringify!(sub_category)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).device_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_wps_device_detail_t),
            "::",
            stringify!(device_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).manufacturer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_wps_device_detail_t),
            "::",
            stringify!(manufacturer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).model_name) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_wps_device_detail_t),
            "::",
            stringify!(model_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).model_number) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_wps_device_detail_t),
            "::",
            stringify!(model_number)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial_number) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_wps_device_detail_t),
            "::",
            stringify!(serial_number)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).config_methods) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_wps_device_detail_t),
            "::",
            stringify!(config_methods)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).os_version) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_wps_device_detail_t),
            "::",
            stringify!(os_version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).authentication_type_flags) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_wps_device_detail_t),
            "::",
            stringify!(authentication_type_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).encryption_type_flags) as usize - ptr as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_wps_device_detail_t),
            "::",
            stringify!(encryption_type_flags)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).add_config_methods_to_probe_resp) as usize - ptr as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_wps_device_detail_t),
            "::",
            stringify!(add_config_methods_to_probe_resp)
        )
    );
}
#[doc = " Structure used to receive the AP credential after WPS is completed successfully from \\ref cy_wcm_wps_enrollee."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cy_wcm_wps_credential_t {
    #[doc = "< AP SSID (name) - must be null-terminated."]
    pub ssid: cy_wcm_ssid_t,
    #[doc = "< AP security type."]
    pub security: cy_wcm_security_t,
    #[doc = "< AP passphrase - must be null-terminated."]
    pub passphrase: cy_wcm_passphrase_t,
}
#[test]
fn bindgen_test_layout_cy_wcm_wps_credential_t() {
    const UNINIT: ::core::mem::MaybeUninit<cy_wcm_wps_credential_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cy_wcm_wps_credential_t>(),
        104usize,
        concat!("Size of: ", stringify!(cy_wcm_wps_credential_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cy_wcm_wps_credential_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cy_wcm_wps_credential_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_wps_credential_t),
            "::",
            stringify!(ssid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).security) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_wps_credential_t),
            "::",
            stringify!(security)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).passphrase) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_wps_credential_t),
            "::",
            stringify!(passphrase)
        )
    );
}
#[doc = " Structure used to receive the information of the associated AP from \\ref cy_wcm_get_associated_ap_info()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cy_wcm_associated_ap_info_t {
    #[doc = "< Associated AP name."]
    pub SSID: cy_wcm_ssid_t,
    #[doc = "< BSSID (MAC address) of the associated AP."]
    pub BSSID: cy_wcm_mac_t,
    #[doc = "< Security of the associated AP. @see cy_wcm_security_t."]
    pub security: cy_wcm_security_t,
    #[doc = "< Channel width (bandwidth in MHz) of the AP."]
    pub channel_width: u16,
    #[doc = "< RSSI in dBm. (<-90=Very poor, >-30=Excellent)."]
    pub signal_strength: i16,
    #[doc = "< Radio channel of the AP."]
    pub channel: u8,
}
#[test]
fn bindgen_test_layout_cy_wcm_associated_ap_info_t() {
    const UNINIT: ::core::mem::MaybeUninit<cy_wcm_associated_ap_info_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cy_wcm_associated_ap_info_t>(),
        52usize,
        concat!("Size of: ", stringify!(cy_wcm_associated_ap_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cy_wcm_associated_ap_info_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cy_wcm_associated_ap_info_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SSID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_associated_ap_info_t),
            "::",
            stringify!(SSID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BSSID) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_associated_ap_info_t),
            "::",
            stringify!(BSSID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).security) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_associated_ap_info_t),
            "::",
            stringify!(security)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).channel_width) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_associated_ap_info_t),
            "::",
            stringify!(channel_width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signal_strength) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_associated_ap_info_t),
            "::",
            stringify!(signal_strength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).channel) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_associated_ap_info_t),
            "::",
            stringify!(channel)
        )
    );
}
#[doc = " Structure used to receive the WLAN statistics of the given interface from the time the WLAN driver is up."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cy_wcm_wlan_statistics_t {
    #[doc = "< Total received bytes."]
    pub rx_bytes: u32,
    #[doc = "< Total transmitted bytes."]
    pub tx_bytes: u32,
    #[doc = "< Total received WLAN packets."]
    pub rx_packets: u32,
    #[doc = "< Total transmitted WLAN packets."]
    pub tx_packets: u32,
    #[doc = "< Total transmission retries."]
    pub tx_retries: u32,
    #[doc = "< Total failed packets."]
    pub tx_failed: u32,
    #[doc = "< Current transmitted data rate in Kbps"]
    pub tx_bitrate: u32,
}
#[test]
fn bindgen_test_layout_cy_wcm_wlan_statistics_t() {
    const UNINIT: ::core::mem::MaybeUninit<cy_wcm_wlan_statistics_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cy_wcm_wlan_statistics_t>(),
        28usize,
        concat!("Size of: ", stringify!(cy_wcm_wlan_statistics_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cy_wcm_wlan_statistics_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cy_wcm_wlan_statistics_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_wlan_statistics_t),
            "::",
            stringify!(rx_bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_bytes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_wlan_statistics_t),
            "::",
            stringify!(tx_bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_packets) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_wlan_statistics_t),
            "::",
            stringify!(rx_packets)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_packets) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_wlan_statistics_t),
            "::",
            stringify!(tx_packets)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_retries) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_wlan_statistics_t),
            "::",
            stringify!(tx_retries)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_failed) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_wlan_statistics_t),
            "::",
            stringify!(tx_failed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_bitrate) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_wlan_statistics_t),
            "::",
            stringify!(tx_bitrate)
        )
    );
}
#[doc = " Structure used to fill the vendor information element (IE) as a part of starting SoftAP. \\ref cy_wcm_start_ap."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cy_wcm_custom_ie_info_t {
    #[doc = "< Unique identifier for the IE."]
    pub oui: [u8; 3usize],
    #[doc = "< Sub-type of the IE."]
    pub subtype: u8,
    #[doc = "< Pointer to IE data."]
    pub data: *mut ::core::ffi::c_void,
    #[doc = "< IE data length."]
    pub length: u16,
    #[doc = "< Mask of the IE details to be included \\ref cy_wcm_ie_mask_t"]
    pub ie_packet_mask: u16,
}
#[test]
fn bindgen_test_layout_cy_wcm_custom_ie_info_t() {
    const UNINIT: ::core::mem::MaybeUninit<cy_wcm_custom_ie_info_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cy_wcm_custom_ie_info_t>(),
        24usize,
        concat!("Size of: ", stringify!(cy_wcm_custom_ie_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cy_wcm_custom_ie_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cy_wcm_custom_ie_info_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).oui) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_custom_ie_info_t),
            "::",
            stringify!(oui)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subtype) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_custom_ie_info_t),
            "::",
            stringify!(subtype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_custom_ie_info_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_custom_ie_info_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ie_packet_mask) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_custom_ie_info_t),
            "::",
            stringify!(ie_packet_mask)
        )
    );
}
#[doc = " Structure used to configure the access point. \\ref cy_wcm_start_ap."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cy_wcm_ap_config_t {
    #[doc = "< AP credentials."]
    pub ap_credentials: cy_wcm_ap_credentials_t,
    #[doc = "< Radio channel of the AP."]
    pub channel: u8,
    #[doc = "< IP settings of the AP interface."]
    pub ip_settings: cy_wcm_ip_setting_t,
    #[doc = "< Optional custom IE information to be added to the SoftAP."]
    pub ie_info: *mut cy_wcm_custom_ie_info_t,
}
#[test]
fn bindgen_test_layout_cy_wcm_ap_config_t() {
    const UNINIT: ::core::mem::MaybeUninit<cy_wcm_ap_config_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cy_wcm_ap_config_t>(),
        176usize,
        concat!("Size of: ", stringify!(cy_wcm_ap_config_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cy_wcm_ap_config_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cy_wcm_ap_config_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ap_credentials) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_ap_config_t),
            "::",
            stringify!(ap_credentials)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).channel) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_ap_config_t),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip_settings) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_ap_config_t),
            "::",
            stringify!(ip_settings)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ie_info) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_wcm_ap_config_t),
            "::",
            stringify!(ie_info)
        )
    );
}
#[doc = " \\addtogroup group_wcm_typedefs\n \\{\n/\n/**\n Wi-Fi scan result callback function pointer type.\n\n @param[in] result_ptr       : A pointer to the scan result; the scan result will be freed once the callback function returns from the application.\n                               There will not be any scan result when the scan status is CY_WCM_SCAN_COMPLETE.\n                               For more details on content of result_ptr, see \\ref cy_wcm_scan_result_t.\n @param[in] user_data        : User-provided data.\n @param[in] status           : Status of the scan process.\n                               CY_WCM_SCAN_COMPLETE   : Indicates the scan is completed. In this case, the result_ptr will not contain any results.\n                               CY_WCM_SCAN_INCOMPLETE : Indicates the scan is in progress. In this case, result_ptr contains one of the scan result.\n\n\n Note: The callback function will be executed in the context of the WCM."]
pub type cy_wcm_scan_result_callback_t = ::core::option::Option<
    unsafe extern "C" fn(
        result_ptr: *mut cy_wcm_scan_result_t,
        user_data: *mut ::core::ffi::c_void,
        status: cy_wcm_scan_status_t,
    ),
>;
#[doc = " WCM event callback function pointer type; events are invoked when the WHD posts events to WCM.\n @param[in] event            : WCM events.\n @param[in] event_data       : A pointer to the event data. The event data will be freed once the callback returns from the application.\n\n Note: The callback function will be executed in the context of the WCM."]
pub type cy_wcm_event_callback_t = ::core::option::Option<
    unsafe extern "C" fn(event: cy_wcm_event_t, event_data: *mut cy_wcm_event_data_t),
>;
extern "C" {
    #[doc = " Initializes the WCM.\n\n This function initializes the WCM resources, WHD, and Wi-Fi transport;\n turns Wi-Fi on; and starts up the network stack. This function should be called before calling other WCM APIs.\n\n This function is supported in multi-core environment and it must be called in secondary core application before invoking any virtual WCM APIs.\n \\note The secondary core can invoke this API by passing the config parameter as NULL.\n\n @param[in]  config: The configuration to be initialized.\n\n @return CY_RSLT_SUCCESS if WCM initialization was successful; returns \\ref cy_wcm_error otherwise.\n"]
    pub fn cy_wcm_init(config: *mut cy_wcm_config_t) -> cy_rslt_t;
}
extern "C" {
    #[doc = " Shuts down the WCM.\n\n This function cleans up all the resources of the WCM and brings down the Wi-Fi driver.\n\n This function is supported in multi-core environment and can be invoked in the secondary core application which then cleans up all the resources of WCM in secondary core.\n\n \\note This API does not bring down the network stack because the default underlying stack does not have\n       an implementation for deinit. Therefore, the expectation is that \\ref cy_wcm_init and this API should\n       be invoked only once.\n\n @return CY_RSLT_SUCCESS if the Wi-Fi module was successfully turned off; returns \\ref cy_wcm_error otherwise."]
    pub fn cy_wcm_deinit() -> cy_rslt_t;
}
extern "C" {
    #[doc = " Performs a Wi-Fi network scan.\n The scan progressively accumulates results over time and may take between 1 and 10 seconds to complete.\n The results of the scan will be individually provided to the callback function.\n This API can be invoked while being connected to an AP.\n\n  @param[in]  scan_callback  : Callback function which receives the scan results;\n                               callback will be executed in the context of the WCM.\n                               Scan results will be individually provided to this callback function.\n                               For more details on the scan results, see \\ref cy_wcm_scan_result_callback_t.\n  @param[in]  user_data      : User data to be returned as an argument in the callback function\n                               when the callback function is invoked.\n  @param[in]  scan_filter    : Scan filter parameter passed for scanning (optional).\n\n @return CY_RSLT_SUCCESS if the Wi-Fi network scan was successful; returns \\ref cy_wcm_error otherwise.\n While a scan is in progress, if the user issues another scan, this API returns \"CY_RSLT_WCM_SCAN_IN_PROGRESS\".\n"]
    pub fn cy_wcm_start_scan(
        scan_callback: cy_wcm_scan_result_callback_t,
        user_data: *mut ::core::ffi::c_void,
        scan_filter: *mut cy_wcm_scan_filter_t,
    ) -> cy_rslt_t;
}
extern "C" {
    #[doc = " Stops an ongoing Wi-Fi network scan.\n\n @return CY_RSLT_SUCCESS if the Wi-Fi network scan was successful; returns \\ref cy_wcm_error otherwise.\n"]
    pub fn cy_wcm_stop_scan() -> cy_rslt_t;
}
extern "C" {
    #[doc = " Connects the STA interface to a AP using the Wi-Fi credentials and configuration parameters provided.\n On a successful connection to the Wi-Fi network, the API returns the IP address.\n If the user does not know the security type of the AP then, connect_param.ap_credentials.security must\n be set to CY_WCM_SECURITY_UNKNOWN so that the library will internally find the security type before\n connecting to AP.\n\n This API is a blocking call; this function additionally performs the following checks:\n 1) Checks for and ignores duplicate connect requests to an already connected AP.\n 2) Checks the current connection state; if already connected, disconnects from the current\n    Wi-Fi network and connects to the new Wi-Fi network.\n 3) If the user does not know the security type of the AP, the library internally finds the security type.\n\n @param[in]   connect_params      : Configuration to join the AP.\n @param[out]  ip_addr             : Pointer to return the IP address (optional).\n\n \\note WEP (Wired Equivalent Privacy) security is not supported by this API.\n       WEP-based authentication types are considered to be weaker security types;\n       therefore, this function doesn't connect to an AP that is configured with WEP-based authentication.\n\n @return CY_RSLT_SUCCESS if connection is successful; returns \\ref cy_wcm_error otherwise."]
    pub fn cy_wcm_connect_ap(
        connect_params: *mut cy_wcm_connect_params_t,
        ip_addr: *mut cy_wcm_ip_address_t,
    ) -> cy_rslt_t;
}
extern "C" {
    #[doc = " Disconnects the STA interface from the currently connected AP.\n\n @return CY_RSLT_SUCCESS if disconnection was successful or if the device is already\n disconnected; returns \\ref cy_wcm_error otherwise."]
    pub fn cy_wcm_disconnect_ap() -> cy_rslt_t;
}
extern "C" {
    #[doc = " Retrieves the IPv4 address of the given interface. See \\ref cy_wcm_get_ipv6_addr API to get IPv6 addresses.\n\n @param[in]   interface_type  : Type of the WCM interface.\n @param[out]  ip_addr         : Pointer to an IP address structure (or) an IP address structure array.\n                                If the given interface is CY_WCM_INTERFACE_TYPE_STA or CY_WCM_INTERFACE_TYPE_AP upon return, index-0 stores the IPv4 address of the interface.\n                                If the given interface type is CY_WCM_INTERFACE_TYPE_AP_STA, index-0 stores the IPv4 address of the STA interface and index-1 stores the IPv4 address of the AP interface. ip_addr should have enough valid memory to hold two IP address structures.\n\n @return CY_RSLT_SUCCESS if IP-address get is successful; returns \\ref cy_wcm_error otherwise.\n"]
    pub fn cy_wcm_get_ip_addr(
        interface_type: cy_wcm_interface_t,
        ip_addr: *mut cy_wcm_ip_address_t,
    ) -> cy_rslt_t;
}
extern "C" {
    #[doc = " Retrieves the IPv6 address of the given interface.\n\n Note: Currently, this API supports only \\ref CY_WCM_IPV6_LINK_LOCAL type.\n\n @param[in]   interface_type  : Type of the WCM interface.\n @param[in]   ipv6_addr_type  : IPv6 address type.\n @param[out]  ip_addr         : Pointer to an IP address structure (or) an IP address structure array.\n                                If the given interface is CY_WCM_INTERFACE_TYPE_STA or CY_WCM_INTERFACE_TYPE_AP upon return, index-0 stores the IPv6 link-local address of the interface.\n                                If the given interface type is CY_WCM_INTERFACE_TYPE_AP_STA, index-0 stores the IPv6 link-local address of the STA interface and index-1 stores the IPv6 link-local address of the AP interface. ip_addr should have enough valid memory to hold two IP address structures.\n\n @return CY_RSLT_SUCCESS if IPv6 interface is up and IPv6 address is ready; returns \\ref cy_wcm_error otherwise."]
    pub fn cy_wcm_get_ipv6_addr(
        interface_type: cy_wcm_interface_t,
        ipv6_addr_type: cy_wcm_ipv6_type_t,
        ip_addr: *mut cy_wcm_ip_address_t,
    ) -> cy_rslt_t;
}
extern "C" {
    #[doc = " Retrieves the gateway IP address of the given interface.\n\n @param[in]   interface_type  : Type of the WCM interface.\n @param[out]  gateway_addr    : Pointer to a single structure or an array of structures to be filled with the gateway IP address or addresses.\n                                If the given interface is CY_WCM_INTERFACE_TYPE_STA or CY_WCM_INTERFACE_TYPE_AP upon return, index-0 stores the IPv4 gateway address of the interface.\n                                If the given interface type is CY_WCM_INTERFACE_TYPE_AP_STA, index-0 stores the IPv4 gateway address of the STA interface and index-1 stores the IPV4 gateway address of the AP interface. gateway_addr should have enough valid memory to hold two IP address structures.\n                                In future, IPv6 addresses will be supported.\n\n\n @return CY_RSLT_SUCCESS if retrieval of the gateway IP address was successful; returns \\ref cy_wcm_error otherwise."]
    pub fn cy_wcm_get_gateway_ip_address(
        interface_type: cy_wcm_interface_t,
        gateway_addr: *mut cy_wcm_ip_address_t,
    ) -> cy_rslt_t;
}
extern "C" {
    #[doc = " Retrieves the subnet mask address of the given interface.\n\n @param[in]   interface_type  : Type of the WCM interface.\n @param[out]  net_mask_addr   : Pointer to a single structure or an array of structures to be filled with the subnet mask address or masks.\n                                If the given interface is CY_WCM_INTERFACE_TYPE_STA or CY_WCM_INTERFACE_TYPE_AP upon return, index-0 stores the subnet mask address of the interface.\n                                If the given interface type is CY_WCM_INTERFACE_TYPE_AP_STA, index-0 stores the subnet mask address of the STA interface and index-1 stores the subnet mask address of the AP interface. net_mask_addr should have enough valid memory to hold two IP address structures.\n\n\n @return CY_RSLT_SUCCESS if retrieval of the subnet mask address was successful; returns \\ref cy_wcm_error otherwise."]
    pub fn cy_wcm_get_ip_netmask(
        interface_type: cy_wcm_interface_t,
        net_mask_addr: *mut cy_wcm_ip_address_t,
    ) -> cy_rslt_t;
}
extern "C" {
    #[doc = " Retrieves the MAC address of the given interface.\n\n @param[in]   interface_type  : Type of the WCM interface.\n @param[out]  mac_addr        : Pointer to a MAC address structure (or) a MAC address structure array.\n                                If the given interface is CY_WCM_INTERFACE_TYPE_STA or CY_WCM_INTERFACE_TYPE_AP upon return, index-0 stores the MAC address of the interface.\n                                If the given interface type is CY_WCM_INTERFACE_TYPE_AP_STA, index-0 stores the MAC address of the STA interface and index-1 stores the MAC address of the AP interface. mac_addr should have enough valid memory to hold two MAC address structures.\n\n\n @return CY_RSLT_SUCCESS if the MAC address get is successful; returns \\ref cy_wcm_error otherwise."]
    pub fn cy_wcm_get_mac_addr(
        interface_type: cy_wcm_interface_t,
        mac_addr: *mut cy_wcm_mac_t,
    ) -> cy_rslt_t;
}
extern "C" {
    #[doc = " Negotiates securely with a Wi-Fi Protected Setup (WPS) Registrar (usually an\n  AP) and obtains the Wi-Fi network credentials.\n\n @param[in]  config               : Pointer to the WPS configuration information.\n @param[in]  details              : Pointer to a structure containing manufacturing details\n                                    of this device.\n @param[out] credentials          : Pointer to an array of credentials structure \\ref cy_wcm_wps_credential_t to receive the AP credentials.\n @param[in, out] credential_count : Upon invocation, this parameter stores the size of the credentials parameter. Upon return, denotes the actual\n                                    number of credentials returned.\n\n @return CY_RSLT_SUCCESS if credentials are retrieved successfully; returns \\ref cy_wcm_error otherwise."]
    pub fn cy_wcm_wps_enrollee(
        config: *mut cy_wcm_wps_config_t,
        details: *const cy_wcm_wps_device_detail_t,
        credentials: *mut cy_wcm_wps_credential_t,
        credential_count: *mut u16,
    ) -> cy_rslt_t;
}
extern "C" {
    #[doc = " Generates a random WPS PIN for PIN mode connection.\n\n @param[out]  wps_pin_string  : Pointer to store the WPS PIN as a null-terminated string.\n\n @return CY_RSLT_SUCCESS if WPS PIN generated; returns \\ref cy_wcm_error otherwise."]
    pub fn cy_wcm_wps_generate_pin(wps_pin_string: *mut ::core::ffi::c_char) -> cy_rslt_t;
}
extern "C" {
    #[doc = " Registers an event callback to monitor the connection and IP address change events.\n This is an optional registration; use it if the application needs to monitor events across disconnection and reconnection of the STA interface and notifies the clients which are connected or disconnected from the SoftAP.\n\n This API is supported in multi-core environment and can be invoked as a virtual API from the secondary core application.\n\n Note: This API is expected to be called typically while being connected to an AP or once the SoftAP is up.\n\n @param[in]  event_callback  : Callback function to be invoked for event notification.\n                               The callback will be executed in the context of the WCM.\n\n @return CY_RSLT_SUCCESS if application callback registration was successful; returns \\ref cy_wcm_error otherwise."]
    pub fn cy_wcm_register_event_callback(event_callback: cy_wcm_event_callback_t) -> cy_rslt_t;
}
extern "C" {
    #[doc = " De-registers an event callback.\n\n This API is supported in multi-core environment and can be invoked as a virtual API from the secondary core application.\n\n @param[in]  event_callback  : Callback function to de-register from getting notifications.\n\n @return CY_RSLT_SUCCESS if application callback de-registration was successful; returns \\ref cy_wcm_error otherwise."]
    pub fn cy_wcm_deregister_event_callback(event_callback: cy_wcm_event_callback_t) -> cy_rslt_t;
}
extern "C" {
    #[doc = " Checks if the STA interface is connected to an AP.\n\n This API is supported in multi-core environment and can be invoked as a virtual API from the secondary core application.\n\n @return 1 if connected, 0 otherwise."]
    pub fn cy_wcm_is_connected_to_ap() -> u8;
}
extern "C" {
    #[doc = " Retrieves the information such as SSID, BSSID, and other details of the AP to which the STA interface is connected.\n\n @param[out] ap_info : Pointer to store the information of the associated AP \\ref cy_wcm_associated_ap_info_t.\n\n @return CY_RSLT_SUCCESS if retrieving the information of the associated AP was successful; returns \\ref cy_wcm_error otherwise."]
    pub fn cy_wcm_get_associated_ap_info(ap_info: *mut cy_wcm_associated_ap_info_t) -> cy_rslt_t;
}
extern "C" {
    #[doc = " Gets the WLAN statistics of the given interface from the time WLAN driver is up and running.\n\n The application would typically use this API to get information such as \"total transmitted packets\" and \"total received packets\";\n for more details, see members of \\ref cy_wcm_wlan_statistics_t.\n\n @param[in] interface : Type of the WCM interface.\n @param[in] stat      : Pointer to store the statistics \\ref cy_wcm_wlan_statistics_t.\n\n @return CY_RSLT_SUCCESS if retrieval of statistics was successful; returns \\ref cy_wcm_error otherwise."]
    pub fn cy_wcm_get_wlan_statistics(
        interface: cy_wcm_interface_t,
        stat: *mut cy_wcm_wlan_statistics_t,
    ) -> cy_rslt_t;
}
extern "C" {
    #[doc = " Retrieves the MAC address of the gateway for STA interface. Uses Address Resolution Protocol (ARP) to retrieve the gateway MAC address.\n\n This function is a blocking call and uses an internal timeout while running ARP.\n\n @param[out]  mac_addr : Pointer to a MAC address structure which is filled with the gateway's MAC address on successful return.\n\n @return CY_RSLT_SUCCESS if retrieval of the gateway MAC address was successful; returns \\ref cy_wcm_error otherwise."]
    pub fn cy_wcm_get_gateway_mac_address(mac_addr: *mut cy_wcm_mac_t) -> cy_rslt_t;
}
extern "C" {
    #[doc = " Sends a ping request to the given IP address. This function is a blocking call; it returns after the specified timeout.\n\n @param[in]  interface   : Type of the WCM interface.\n @param[in]  ip_addr     : Pointer to the destination IP address structure to which the ping request will be sent.\n @param[in]  timeout_ms  : Ping request timeout in milliseconds.\n @param[out] elapsed_ms  : Pointer to store the round-trip time (in milliseconds),\n                           i.e., the time taken to receive the ping response from the destination.\n\n @return CY_RSLT_SUCCESS if pinging to the IP address was successful; returns \\ref cy_wcm_error otherwise."]
    pub fn cy_wcm_ping(
        interface: cy_wcm_interface_t,
        ip_addr: *mut cy_wcm_ip_address_t,
        timeout_ms: u32,
        elapsed_ms: *mut u32,
    ) -> cy_rslt_t;
}
extern "C" {
    #[doc = " Starts an infrastructure Wi-Fi network (SoftAP).\n This API is a blocking call; this function adds the information element to the SoftAP and starts an internal DHCP server.\n\n @param[in]   ap_config   : Configuration parameters for the SoftAP.\n\n @return CY_RSLT_SUCCESS if SoftAp is started ; returns \\ref cy_wcm_error otherwise."]
    pub fn cy_wcm_start_ap(ap_config: *const cy_wcm_ap_config_t) -> cy_rslt_t;
}
extern "C" {
    #[doc = " Stops the infrastructure Wi-Fi network (SoftAP), removes the information element and stops the internal DHCP server.\n\n @return CY_RSLT_SUCCESS if connection is successful; returns \\ref cy_wcm_error otherwise."]
    pub fn cy_wcm_stop_ap() -> cy_rslt_t;
}
extern "C" {
    #[doc = " Gets the MAC address of the clients associated with the SoftAP.\n\n @param[out] sta_list    : Pointer to the MAC address (or) array of MAC addresses. The client's (STA) MAC address is stored on this array before the function returns.\n\n @param[in]  num_clients : Length of the array passed in sta_list.\n\n \\note If the number of connected clients is less than the num_clients, then elements of sta_list beyond number of connected clients will be set to zero.\n       The maximum number of supported client list varies for different Wi-Fi chips.\n\n @return CY_RSLT_SUCCESS If getting the client list is successful; returns \\ref cy_wcm_error otherwise."]
    pub fn cy_wcm_get_associated_client_list(
        sta_list: *mut cy_wcm_mac_t,
        num_clients: u8,
    ) -> cy_rslt_t;
}
extern "C" {
    #[doc = " Stores the AP settings provided by the user.\n NOTE: Dotted-decimal format example: 192.168.0.1\n\n @param[in] ip_addr       : Pointer to an array containing the IP address of the AP in dotted-decimal format.\n @param[in] netmask       : Pointer to an array containing the network mask in dotted-decimal format.\n @param[in] gateway_addr  : Pointer to an array containing the gateway address in dotted-decimal format.\n @param[in] ver           : IP version. Possible values \\ref CY_WCM_IP_VER_V6 or \\ref CY_WCM_IP_VER_V4.\n @param[in] ap_ip         : Pointer to the variable which stores AP settings.\n\n @result CY_RSLT_SUCCESS if the AP settings are successfully stored in the user-provided variable; returns \\ref cy_wcm_error otherwise."]
    pub fn cy_wcm_set_ap_ip_setting(
        ap_ip: *mut cy_wcm_ip_setting_t,
        ip_addr: *const ::core::ffi::c_char,
        netmask: *const ::core::ffi::c_char,
        gateway_addr: *const ::core::ffi::c_char,
        ver: cy_wcm_ip_version_t,
    ) -> cy_rslt_t;
}
extern "C" {
    #[doc = " Sets low power mode capability for WLAN CPU\n\n @param[in] mode - can be one of:\n                  CY_WCM_NO_POWERSAVE_MODE  WLAN CPU will not go into powersave mode\n                  CY_WCM_PM1_POWERSAVE_MODE Powersave mode on specified interface without regard for throughput reduction\n                  CY_WCM_PM2_POWERSAVE_MODE Powersave mode on specified interface with High throughput\n\n @return CY_RSLT_SUCCESS if the Wi-Fi module mode was successfully changed; returns \\ref cy_wcm_error otherwise."]
    pub fn cy_wcm_allow_low_power_mode(mode: cy_wcm_powersave_mode_t) -> cy_rslt_t;
}
