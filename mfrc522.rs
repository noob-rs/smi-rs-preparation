#![allow(non_upper_case_globals, non_camel_case_types, non_snake_case, unused)]
/* automatically generated by rust-bindgen 0.69.4 */

#[doc = " \\brief Serial Communications Block (SPI/UART/I2C) (CySCB)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CySCB_V1_Type {
    #[doc = "< 0x00000000 Generic control"]
    pub CTRL: u32,
    #[doc = "< 0x00000004 Generic status"]
    pub STATUS: u32,
    #[doc = "< 0x00000008 Command/response control"]
    pub CMD_RESP_CTRL: u32,
    #[doc = "< 0x0000000C Command/response status"]
    pub CMD_RESP_STATUS: u32,
    pub RESERVED: [u32; 4usize],
    #[doc = "< 0x00000020 SPI control"]
    pub SPI_CTRL: u32,
    #[doc = "< 0x00000024 SPI status"]
    pub SPI_STATUS: u32,
    pub RESERVED1: [u32; 6usize],
    #[doc = "< 0x00000040 UART control"]
    pub UART_CTRL: u32,
    #[doc = "< 0x00000044 UART transmitter control"]
    pub UART_TX_CTRL: u32,
    #[doc = "< 0x00000048 UART receiver control"]
    pub UART_RX_CTRL: u32,
    #[doc = "< 0x0000004C UART receiver status"]
    pub UART_RX_STATUS: u32,
    #[doc = "< 0x00000050 UART flow control"]
    pub UART_FLOW_CTRL: u32,
    pub RESERVED2: [u32; 3usize],
    #[doc = "< 0x00000060 I2C control"]
    pub I2C_CTRL: u32,
    #[doc = "< 0x00000064 I2C status"]
    pub I2C_STATUS: u32,
    #[doc = "< 0x00000068 I2C master command"]
    pub I2C_M_CMD: u32,
    #[doc = "< 0x0000006C I2C slave command"]
    pub I2C_S_CMD: u32,
    #[doc = "< 0x00000070 I2C configuration"]
    pub I2C_CFG: u32,
    pub RESERVED3: [u32; 99usize],
    #[doc = "< 0x00000200 Transmitter control"]
    pub TX_CTRL: u32,
    #[doc = "< 0x00000204 Transmitter FIFO control"]
    pub TX_FIFO_CTRL: u32,
    #[doc = "< 0x00000208 Transmitter FIFO status"]
    pub TX_FIFO_STATUS: u32,
    pub RESERVED4: [u32; 13usize],
    #[doc = "< 0x00000240 Transmitter FIFO write"]
    pub TX_FIFO_WR: u32,
    pub RESERVED5: [u32; 47usize],
    #[doc = "< 0x00000300 Receiver control"]
    pub RX_CTRL: u32,
    #[doc = "< 0x00000304 Receiver FIFO control"]
    pub RX_FIFO_CTRL: u32,
    #[doc = "< 0x00000308 Receiver FIFO status"]
    pub RX_FIFO_STATUS: u32,
    pub RESERVED6: u32,
    #[doc = "< 0x00000310 Slave address and mask"]
    pub RX_MATCH: u32,
    pub RESERVED7: [u32; 11usize],
    #[doc = "< 0x00000340 Receiver FIFO read"]
    pub RX_FIFO_RD: u32,
    #[doc = "< 0x00000344 Receiver FIFO read silent"]
    pub RX_FIFO_RD_SILENT: u32,
    pub RESERVED8: [u32; 46usize],
    #[doc = "< 0x00000400 Memory buffer"]
    pub EZ_DATA: [u32; 512usize],
    pub RESERVED9: [u32; 128usize],
    #[doc = "< 0x00000E00 Active clocked interrupt signal"]
    pub INTR_CAUSE: u32,
    pub RESERVED10: [u32; 31usize],
    #[doc = "< 0x00000E80 Externally clocked I2C interrupt request"]
    pub INTR_I2C_EC: u32,
    pub RESERVED11: u32,
    #[doc = "< 0x00000E88 Externally clocked I2C interrupt mask"]
    pub INTR_I2C_EC_MASK: u32,
    #[doc = "< 0x00000E8C Externally clocked I2C interrupt masked"]
    pub INTR_I2C_EC_MASKED: u32,
    pub RESERVED12: [u32; 12usize],
    #[doc = "< 0x00000EC0 Externally clocked SPI interrupt request"]
    pub INTR_SPI_EC: u32,
    pub RESERVED13: u32,
    #[doc = "< 0x00000EC8 Externally clocked SPI interrupt mask"]
    pub INTR_SPI_EC_MASK: u32,
    #[doc = "< 0x00000ECC Externally clocked SPI interrupt masked"]
    pub INTR_SPI_EC_MASKED: u32,
    pub RESERVED14: [u32; 12usize],
    #[doc = "< 0x00000F00 Master interrupt request"]
    pub INTR_M: u32,
    #[doc = "< 0x00000F04 Master interrupt set request"]
    pub INTR_M_SET: u32,
    #[doc = "< 0x00000F08 Master interrupt mask"]
    pub INTR_M_MASK: u32,
    #[doc = "< 0x00000F0C Master interrupt masked request"]
    pub INTR_M_MASKED: u32,
    pub RESERVED15: [u32; 12usize],
    #[doc = "< 0x00000F40 Slave interrupt request"]
    pub INTR_S: u32,
    #[doc = "< 0x00000F44 Slave interrupt set request"]
    pub INTR_S_SET: u32,
    #[doc = "< 0x00000F48 Slave interrupt mask"]
    pub INTR_S_MASK: u32,
    #[doc = "< 0x00000F4C Slave interrupt masked request"]
    pub INTR_S_MASKED: u32,
    pub RESERVED16: [u32; 12usize],
    #[doc = "< 0x00000F80 Transmitter interrupt request"]
    pub INTR_TX: u32,
    #[doc = "< 0x00000F84 Transmitter interrupt set request"]
    pub INTR_TX_SET: u32,
    #[doc = "< 0x00000F88 Transmitter interrupt mask"]
    pub INTR_TX_MASK: u32,
    #[doc = "< 0x00000F8C Transmitter interrupt masked request"]
    pub INTR_TX_MASKED: u32,
    pub RESERVED17: [u32; 12usize],
    #[doc = "< 0x00000FC0 Receiver interrupt request"]
    pub INTR_RX: u32,
    #[doc = "< 0x00000FC4 Receiver interrupt set request"]
    pub INTR_RX_SET: u32,
    #[doc = "< 0x00000FC8 Receiver interrupt mask"]
    pub INTR_RX_MASK: u32,
    #[doc = "< 0x00000FCC Receiver interrupt masked request"]
    pub INTR_RX_MASKED: u32,
}
#[test]
fn bindgen_test_layout_CySCB_V1_Type() {
    const UNINIT: ::core::mem::MaybeUninit<CySCB_V1_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CySCB_V1_Type>(),
        4048usize,
        concat!("Size of: ", stringify!(CySCB_V1_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<CySCB_V1_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(CySCB_V1_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(CTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).STATUS) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CMD_RESP_CTRL) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(CMD_RESP_CTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CMD_RESP_STATUS) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(CMD_RESP_STATUS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(RESERVED)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SPI_CTRL) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(SPI_CTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SPI_STATUS) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(SPI_STATUS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED1) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UART_CTRL) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(UART_CTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UART_TX_CTRL) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(UART_TX_CTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UART_RX_CTRL) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(UART_RX_CTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UART_RX_STATUS) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(UART_RX_STATUS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UART_FLOW_CTRL) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(UART_FLOW_CTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED2) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(RESERVED2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).I2C_CTRL) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(I2C_CTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).I2C_STATUS) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(I2C_STATUS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).I2C_M_CMD) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(I2C_M_CMD)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).I2C_S_CMD) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(I2C_S_CMD)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).I2C_CFG) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(I2C_CFG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED3) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(RESERVED3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TX_CTRL) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(TX_CTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TX_FIFO_CTRL) as usize - ptr as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(TX_FIFO_CTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TX_FIFO_STATUS) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(TX_FIFO_STATUS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED4) as usize - ptr as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(RESERVED4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TX_FIFO_WR) as usize - ptr as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(TX_FIFO_WR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED5) as usize - ptr as usize },
        580usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(RESERVED5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RX_CTRL) as usize - ptr as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(RX_CTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RX_FIFO_CTRL) as usize - ptr as usize },
        772usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(RX_FIFO_CTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RX_FIFO_STATUS) as usize - ptr as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(RX_FIFO_STATUS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED6) as usize - ptr as usize },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(RESERVED6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RX_MATCH) as usize - ptr as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(RX_MATCH)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED7) as usize - ptr as usize },
        788usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(RESERVED7)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RX_FIFO_RD) as usize - ptr as usize },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(RX_FIFO_RD)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RX_FIFO_RD_SILENT) as usize - ptr as usize },
        836usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(RX_FIFO_RD_SILENT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED8) as usize - ptr as usize },
        840usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(RESERVED8)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EZ_DATA) as usize - ptr as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(EZ_DATA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED9) as usize - ptr as usize },
        3072usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(RESERVED9)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTR_CAUSE) as usize - ptr as usize },
        3584usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(INTR_CAUSE)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED10) as usize - ptr as usize },
        3588usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(RESERVED10)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTR_I2C_EC) as usize - ptr as usize },
        3712usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(INTR_I2C_EC)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED11) as usize - ptr as usize },
        3716usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(RESERVED11)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTR_I2C_EC_MASK) as usize - ptr as usize },
        3720usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(INTR_I2C_EC_MASK)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTR_I2C_EC_MASKED) as usize - ptr as usize },
        3724usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(INTR_I2C_EC_MASKED)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED12) as usize - ptr as usize },
        3728usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(RESERVED12)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTR_SPI_EC) as usize - ptr as usize },
        3776usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(INTR_SPI_EC)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED13) as usize - ptr as usize },
        3780usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(RESERVED13)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTR_SPI_EC_MASK) as usize - ptr as usize },
        3784usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(INTR_SPI_EC_MASK)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTR_SPI_EC_MASKED) as usize - ptr as usize },
        3788usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(INTR_SPI_EC_MASKED)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED14) as usize - ptr as usize },
        3792usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(RESERVED14)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTR_M) as usize - ptr as usize },
        3840usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(INTR_M)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTR_M_SET) as usize - ptr as usize },
        3844usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(INTR_M_SET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTR_M_MASK) as usize - ptr as usize },
        3848usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(INTR_M_MASK)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTR_M_MASKED) as usize - ptr as usize },
        3852usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(INTR_M_MASKED)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED15) as usize - ptr as usize },
        3856usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(RESERVED15)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTR_S) as usize - ptr as usize },
        3904usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(INTR_S)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTR_S_SET) as usize - ptr as usize },
        3908usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(INTR_S_SET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTR_S_MASK) as usize - ptr as usize },
        3912usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(INTR_S_MASK)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTR_S_MASKED) as usize - ptr as usize },
        3916usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(INTR_S_MASKED)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED16) as usize - ptr as usize },
        3920usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(RESERVED16)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTR_TX) as usize - ptr as usize },
        3968usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(INTR_TX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTR_TX_SET) as usize - ptr as usize },
        3972usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(INTR_TX_SET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTR_TX_MASK) as usize - ptr as usize },
        3976usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(INTR_TX_MASK)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTR_TX_MASKED) as usize - ptr as usize },
        3980usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(INTR_TX_MASKED)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED17) as usize - ptr as usize },
        3984usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(RESERVED17)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTR_RX) as usize - ptr as usize },
        4032usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(INTR_RX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTR_RX_SET) as usize - ptr as usize },
        4036usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(INTR_RX_SET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTR_RX_MASK) as usize - ptr as usize },
        4040usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(INTR_RX_MASK)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTR_RX_MASKED) as usize - ptr as usize },
        4044usize,
        concat!(
            "Offset of field: ",
            stringify!(CySCB_V1_Type),
            "::",
            stringify!(INTR_RX_MASKED)
        )
    );
}
#[doc = " \\brief Serial Communications Block (SPI/UART/I2C) (CySCB)"]
pub type CySCB_Type = CySCB_V1_Type;
pub type cy_israddress = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = "< Clock is active low, data is changed on first edge"]
pub const cy_en_scb_spi_sclk_mode_t_CY_SCB_SPI_CPHA0_CPOL0: cy_en_scb_spi_sclk_mode_t = 0;
#[doc = "< Clock is active low, data is changed on second edge"]
pub const cy_en_scb_spi_sclk_mode_t_CY_SCB_SPI_CPHA1_CPOL0: cy_en_scb_spi_sclk_mode_t = 1;
#[doc = "< Clock is active high, data is changed on first edge"]
pub const cy_en_scb_spi_sclk_mode_t_CY_SCB_SPI_CPHA0_CPOL1: cy_en_scb_spi_sclk_mode_t = 2;
#[doc = "< Clock is active high, data is changed on second edge"]
pub const cy_en_scb_spi_sclk_mode_t_CY_SCB_SPI_CPHA1_CPOL1: cy_en_scb_spi_sclk_mode_t = 3;
#[doc = " SPI SCLK Modes"]
pub type cy_en_scb_spi_sclk_mode_t = u32;
#[doc = "< Signal in question is active low"]
pub const cy_en_scb_spi_polarity_t_CY_SCB_SPI_ACTIVE_LOW: cy_en_scb_spi_polarity_t = 0;
#[doc = "< Signal in question is active high"]
pub const cy_en_scb_spi_polarity_t_CY_SCB_SPI_ACTIVE_HIGH: cy_en_scb_spi_polarity_t = 1;
#[doc = " SPI Polarity"]
pub type cy_en_scb_spi_polarity_t = u32;
#[doc = " Provides the typedef for the callback function called in the\n \\ref Cy_SCB_SPI_Interrupt to notify the user about occurrences of\n \\ref group_scb_spi_macros_callback_events."]
pub type cy_cb_scb_spi_handle_events_t = ::core::option::Option<unsafe extern "C" fn(event: u32)>;
#[doc = " SPI context structure.\n All fields for the context structure are internal. Firmware never reads or\n writes these values. Firmware allocates the structure and provides the\n address of the structure to the driver in function calls. Firmware must\n ensure that the defined instance of this structure remains in scope\n while the drive is in use."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cy_stc_scb_spi_context {
    #[doc = "< The receive status"]
    pub status: u32,
    #[doc = "< The pointer to the receive buffer"]
    pub rxBuf: *mut ::core::ffi::c_void,
    #[doc = "< The receive buffer size"]
    pub rxBufSize: u32,
    #[doc = "< The current location in the receive buffer"]
    pub rxBufIdx: u32,
    #[doc = "< The pointer to the transmit buffer"]
    pub txBuf: *mut ::core::ffi::c_void,
    #[doc = "< The transmit buffer size"]
    pub txBufSize: u32,
    #[doc = "< The current location in the transmit buffer"]
    pub txBufIdx: u32,
    #[doc = " The pointer to an event callback that is called when any of\n \\ref group_scb_spi_macros_callback_events occurs"]
    pub cbEvents: cy_cb_scb_spi_handle_events_t,
    #[doc = "< Tracks the context initialization"]
    pub initKey: u32,
}
#[test]
fn bindgen_test_layout_cy_stc_scb_spi_context() {
    const UNINIT: ::core::mem::MaybeUninit<cy_stc_scb_spi_context> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cy_stc_scb_spi_context>(),
        56usize,
        concat!("Size of: ", stringify!(cy_stc_scb_spi_context))
    );
    assert_eq!(
        ::core::mem::align_of::<cy_stc_scb_spi_context>(),
        8usize,
        concat!("Alignment of ", stringify!(cy_stc_scb_spi_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_stc_scb_spi_context),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rxBuf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_stc_scb_spi_context),
            "::",
            stringify!(rxBuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rxBufSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_stc_scb_spi_context),
            "::",
            stringify!(rxBufSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rxBufIdx) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_stc_scb_spi_context),
            "::",
            stringify!(rxBufIdx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).txBuf) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_stc_scb_spi_context),
            "::",
            stringify!(txBuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).txBufSize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_stc_scb_spi_context),
            "::",
            stringify!(txBufSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).txBufIdx) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_stc_scb_spi_context),
            "::",
            stringify!(txBufIdx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cbEvents) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_stc_scb_spi_context),
            "::",
            stringify!(cbEvents)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).initKey) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cy_stc_scb_spi_context),
            "::",
            stringify!(initKey)
        )
    );
}
#[doc = " SPI context structure.\n All fields for the context structure are internal. Firmware never reads or\n writes these values. Firmware allocates the structure and provides the\n address of the structure to the driver in function calls. Firmware must\n ensure that the defined instance of this structure remains in scope\n while the drive is in use."]
pub type cy_stc_scb_spi_context_t = cy_stc_scb_spi_context;
#[doc = "< Analog to digital converter"]
pub const cyhal_resource_t_CYHAL_RSC_ADC: cyhal_resource_t = 0;
#[doc = "< Analog to digital converter with Analog Mic support"]
pub const cyhal_resource_t_CYHAL_RSC_ADCMIC: cyhal_resource_t = 1;
#[doc = "< Bluetooth communications block"]
pub const cyhal_resource_t_CYHAL_RSC_BLESS: cyhal_resource_t = 2;
#[doc = "< CAN communication block"]
pub const cyhal_resource_t_CYHAL_RSC_CAN: cyhal_resource_t = 3;
#[doc = "< Clock Path. DEPRECATED."]
pub const cyhal_resource_t_CYHAL_RSC_CLKPATH: cyhal_resource_t = 4;
#[doc = "< Clock"]
pub const cyhal_resource_t_CYHAL_RSC_CLOCK: cyhal_resource_t = 5;
#[doc = "< Crypto hardware accelerator"]
pub const cyhal_resource_t_CYHAL_RSC_CRYPTO: cyhal_resource_t = 6;
#[doc = "< Digital to analog converter"]
pub const cyhal_resource_t_CYHAL_RSC_DAC: cyhal_resource_t = 7;
#[doc = "< DMA controller"]
pub const cyhal_resource_t_CYHAL_RSC_DMA: cyhal_resource_t = 8;
#[doc = "< Datawire DMA controller"]
pub const cyhal_resource_t_CYHAL_RSC_DW: cyhal_resource_t = 9;
#[doc = "< Ethernet communications block"]
pub const cyhal_resource_t_CYHAL_RSC_ETH: cyhal_resource_t = 10;
#[doc = "< General purpose I/O pin"]
pub const cyhal_resource_t_CYHAL_RSC_GPIO: cyhal_resource_t = 11;
#[doc = "< I2S communications block"]
pub const cyhal_resource_t_CYHAL_RSC_I2S: cyhal_resource_t = 12;
#[doc = "< I3C communications block"]
pub const cyhal_resource_t_CYHAL_RSC_I3C: cyhal_resource_t = 13;
#[doc = "< KeyScan block"]
pub const cyhal_resource_t_CYHAL_RSC_KEYSCAN: cyhal_resource_t = 14;
#[doc = "< Segment LCD controller"]
pub const cyhal_resource_t_CYHAL_RSC_LCD: cyhal_resource_t = 15;
#[doc = "< LIN communications block"]
pub const cyhal_resource_t_CYHAL_RSC_LIN: cyhal_resource_t = 16;
#[doc = "< Low power comparator"]
pub const cyhal_resource_t_CYHAL_RSC_LPCOMP: cyhal_resource_t = 17;
#[doc = "< Low power timer"]
pub const cyhal_resource_t_CYHAL_RSC_LPTIMER: cyhal_resource_t = 18;
#[doc = "< Opamp"]
pub const cyhal_resource_t_CYHAL_RSC_OPAMP: cyhal_resource_t = 19;
#[doc = "< PCM/PDM communications block"]
pub const cyhal_resource_t_CYHAL_RSC_PDM: cyhal_resource_t = 20;
#[doc = "< Quad-SPI communications block"]
pub const cyhal_resource_t_CYHAL_RSC_SMIF: cyhal_resource_t = 21;
#[doc = "< Real time clock"]
pub const cyhal_resource_t_CYHAL_RSC_RTC: cyhal_resource_t = 22;
#[doc = "< Serial Communications Block"]
pub const cyhal_resource_t_CYHAL_RSC_SCB: cyhal_resource_t = 23;
#[doc = "< SD Host Controller"]
pub const cyhal_resource_t_CYHAL_RSC_SDHC: cyhal_resource_t = 24;
#[doc = "< SDIO Device Block"]
pub const cyhal_resource_t_CYHAL_RSC_SDIODEV: cyhal_resource_t = 25;
#[doc = "< Timer/Counter/PWM block"]
pub const cyhal_resource_t_CYHAL_RSC_TCPWM: cyhal_resource_t = 26;
#[doc = "< TDM block"]
pub const cyhal_resource_t_CYHAL_RSC_TDM: cyhal_resource_t = 27;
#[doc = "< UDB Array"]
pub const cyhal_resource_t_CYHAL_RSC_UDB: cyhal_resource_t = 28;
#[doc = "< USB communication block"]
pub const cyhal_resource_t_CYHAL_RSC_USB: cyhal_resource_t = 29;
#[doc = "< Placeholder for invalid type"]
pub const cyhal_resource_t_CYHAL_RSC_INVALID: cyhal_resource_t = 30;
#[doc = " Resource types that the hardware manager supports"]
pub type cyhal_resource_t = u32;
#[doc = "< 8bit Peripheral Divider"]
pub const cyhal_clock_block_t_CYHAL_CLOCK_BLOCK_PERIPHERAL_8BIT: cyhal_clock_block_t = 0;
#[doc = "< 16bit Peripheral Divider"]
pub const cyhal_clock_block_t_CYHAL_CLOCK_BLOCK_PERIPHERAL_16BIT: cyhal_clock_block_t = 1;
#[doc = "< 16.5bit Peripheral Divider"]
pub const cyhal_clock_block_t_CYHAL_CLOCK_BLOCK_PERIPHERAL_16_5BIT: cyhal_clock_block_t = 2;
#[doc = "< 24.5bit Peripheral Divider"]
pub const cyhal_clock_block_t_CYHAL_CLOCK_BLOCK_PERIPHERAL_24_5BIT: cyhal_clock_block_t = 3;
#[doc = "< Internal Main Oscillator Input Clock"]
pub const cyhal_clock_block_t_CYHAL_CLOCK_BLOCK_IMO: cyhal_clock_block_t = 4;
#[doc = "< External Crystal Oscillator Input Clock"]
pub const cyhal_clock_block_t_CYHAL_CLOCK_BLOCK_ECO: cyhal_clock_block_t = 5;
#[doc = "< External Input Clock"]
pub const cyhal_clock_block_t_CYHAL_CLOCK_BLOCK_EXT: cyhal_clock_block_t = 6;
#[doc = "< Alternate High Frequency Input Clock"]
pub const cyhal_clock_block_t_CYHAL_CLOCK_BLOCK_ALTHF: cyhal_clock_block_t = 7;
#[doc = "< Alternate Low Frequency Input Clock"]
pub const cyhal_clock_block_t_CYHAL_CLOCK_BLOCK_ALTLF: cyhal_clock_block_t = 8;
#[doc = "< Internal Low Speed Oscillator Input Clock"]
pub const cyhal_clock_block_t_CYHAL_CLOCK_BLOCK_ILO: cyhal_clock_block_t = 9;
#[doc = "< Precision ILO Input Clock"]
pub const cyhal_clock_block_t_CYHAL_CLOCK_BLOCK_PILO: cyhal_clock_block_t = 10;
#[doc = "< Watch Crystal Oscillator Input Clock"]
pub const cyhal_clock_block_t_CYHAL_CLOCK_BLOCK_WCO: cyhal_clock_block_t = 11;
#[doc = "< Medium Frequency Oscillator Clock"]
pub const cyhal_clock_block_t_CYHAL_CLOCK_BLOCK_MFO: cyhal_clock_block_t = 12;
#[doc = "< Path selection mux for input to FLL/PLLs"]
pub const cyhal_clock_block_t_CYHAL_CLOCK_BLOCK_PATHMUX: cyhal_clock_block_t = 13;
#[doc = "< Frequency-Locked Loop Clock"]
pub const cyhal_clock_block_t_CYHAL_CLOCK_BLOCK_FLL: cyhal_clock_block_t = 14;
#[doc = "< Phase-Locked Loop Clock"]
pub const cyhal_clock_block_t_CYHAL_CLOCK_BLOCK_PLL: cyhal_clock_block_t = 15;
#[doc = "< Low Frequency Clock"]
pub const cyhal_clock_block_t_CYHAL_CLOCK_BLOCK_LF: cyhal_clock_block_t = 16;
#[doc = "< Medium Frequency Clock"]
pub const cyhal_clock_block_t_CYHAL_CLOCK_BLOCK_MF: cyhal_clock_block_t = 17;
#[doc = "< High Frequency Clock"]
pub const cyhal_clock_block_t_CYHAL_CLOCK_BLOCK_HF: cyhal_clock_block_t = 18;
#[doc = "< Analog Pump Clock"]
pub const cyhal_clock_block_t_CYHAL_CLOCK_BLOCK_PUMP: cyhal_clock_block_t = 19;
#[doc = "< Backup Power Domain Clock"]
pub const cyhal_clock_block_t_CYHAL_CLOCK_BLOCK_BAK: cyhal_clock_block_t = 20;
#[doc = "< Timer Clock"]
pub const cyhal_clock_block_t_CYHAL_CLOCK_BLOCK_TIMER: cyhal_clock_block_t = 21;
#[doc = "< Alternative SysTick Clock"]
pub const cyhal_clock_block_t_CYHAL_CLOCK_BLOCK_ALT_SYS_TICK: cyhal_clock_block_t = 22;
#[doc = "< Fast Clock for CM4"]
pub const cyhal_clock_block_t_CYHAL_CLOCK_BLOCK_FAST: cyhal_clock_block_t = 23;
#[doc = "< Peripheral Clock"]
pub const cyhal_clock_block_t_CYHAL_CLOCK_BLOCK_PERI: cyhal_clock_block_t = 24;
#[doc = "< Slow Clock for CM0+"]
pub const cyhal_clock_block_t_CYHAL_CLOCK_BLOCK_SLOW: cyhal_clock_block_t = 25;
#[doc = " Enum for the different types of clocks that exist on the device."]
pub type cyhal_clock_block_t = u32;
#[doc = " @brief Clock object\n Application code should not rely on the specific contents of this struct.\n They are considered an implementation detail which is subject to change\n between platforms and/or HAL releases."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cyhal_clock_t {
    pub block: cyhal_clock_block_t,
    pub channel: u8,
    pub reserved: bool,
    pub funcs: *const ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_cyhal_clock_t() {
    const UNINIT: ::core::mem::MaybeUninit<cyhal_clock_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cyhal_clock_t>(),
        16usize,
        concat!("Size of: ", stringify!(cyhal_clock_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cyhal_clock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cyhal_clock_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_clock_t),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).channel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_clock_t),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_clock_t),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).funcs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_clock_t),
            "::",
            stringify!(funcs)
        )
    );
}
#[doc = " @brief Represents a particular instance of a resource on the chip.\n Application code should not rely on the specific contents of this struct.\n They are considered an implementation detail which is subject to change\n between platforms and/or HAL releases."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cyhal_resource_inst_t {
    #[doc = "!< The resource block type"]
    pub type_: cyhal_resource_t,
    #[doc = "!< The resource block index"]
    pub block_num: u8,
    #[doc = " The channel number, if the resource type defines multiple channels\n per block instance. Otherwise, 0"]
    pub channel_num: u8,
}
#[test]
fn bindgen_test_layout_cyhal_resource_inst_t() {
    const UNINIT: ::core::mem::MaybeUninit<cyhal_resource_inst_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cyhal_resource_inst_t>(),
        8usize,
        concat!("Size of: ", stringify!(cyhal_resource_inst_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cyhal_resource_inst_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cyhal_resource_inst_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_resource_inst_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_num) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_resource_inst_t),
            "::",
            stringify!(block_num)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).channel_num) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_resource_inst_t),
            "::",
            stringify!(channel_num)
        )
    );
}
#[doc = "!< No Connect/Invalid Pin"]
pub const cyhal_gpio_psoc6_02_124_bga_t_NC: cyhal_gpio_psoc6_02_124_bga_t = 255;
#[doc = "!< Port 0 Pin 0"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P0_0: cyhal_gpio_psoc6_02_124_bga_t = 0;
#[doc = "!< Port 0 Pin 1"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P0_1: cyhal_gpio_psoc6_02_124_bga_t = 1;
#[doc = "!< Port 0 Pin 2"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P0_2: cyhal_gpio_psoc6_02_124_bga_t = 2;
#[doc = "!< Port 0 Pin 3"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P0_3: cyhal_gpio_psoc6_02_124_bga_t = 3;
#[doc = "!< Port 0 Pin 4"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P0_4: cyhal_gpio_psoc6_02_124_bga_t = 4;
#[doc = "!< Port 0 Pin 5"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P0_5: cyhal_gpio_psoc6_02_124_bga_t = 5;
#[doc = "!< Port 1 Pin 0"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P1_0: cyhal_gpio_psoc6_02_124_bga_t = 8;
#[doc = "!< Port 1 Pin 1"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P1_1: cyhal_gpio_psoc6_02_124_bga_t = 9;
#[doc = "!< Port 1 Pin 2"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P1_2: cyhal_gpio_psoc6_02_124_bga_t = 10;
#[doc = "!< Port 1 Pin 3"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P1_3: cyhal_gpio_psoc6_02_124_bga_t = 11;
#[doc = "!< Port 1 Pin 4"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P1_4: cyhal_gpio_psoc6_02_124_bga_t = 12;
#[doc = "!< Port 1 Pin 5"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P1_5: cyhal_gpio_psoc6_02_124_bga_t = 13;
#[doc = "!< Port 2 Pin 0"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P2_0: cyhal_gpio_psoc6_02_124_bga_t = 16;
#[doc = "!< Port 2 Pin 1"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P2_1: cyhal_gpio_psoc6_02_124_bga_t = 17;
#[doc = "!< Port 2 Pin 2"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P2_2: cyhal_gpio_psoc6_02_124_bga_t = 18;
#[doc = "!< Port 2 Pin 3"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P2_3: cyhal_gpio_psoc6_02_124_bga_t = 19;
#[doc = "!< Port 2 Pin 4"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P2_4: cyhal_gpio_psoc6_02_124_bga_t = 20;
#[doc = "!< Port 2 Pin 5"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P2_5: cyhal_gpio_psoc6_02_124_bga_t = 21;
#[doc = "!< Port 2 Pin 6"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P2_6: cyhal_gpio_psoc6_02_124_bga_t = 22;
#[doc = "!< Port 2 Pin 7"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P2_7: cyhal_gpio_psoc6_02_124_bga_t = 23;
#[doc = "!< Port 3 Pin 0"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P3_0: cyhal_gpio_psoc6_02_124_bga_t = 24;
#[doc = "!< Port 3 Pin 1"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P3_1: cyhal_gpio_psoc6_02_124_bga_t = 25;
#[doc = "!< Port 3 Pin 2"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P3_2: cyhal_gpio_psoc6_02_124_bga_t = 26;
#[doc = "!< Port 3 Pin 3"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P3_3: cyhal_gpio_psoc6_02_124_bga_t = 27;
#[doc = "!< Port 3 Pin 4"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P3_4: cyhal_gpio_psoc6_02_124_bga_t = 28;
#[doc = "!< Port 3 Pin 5"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P3_5: cyhal_gpio_psoc6_02_124_bga_t = 29;
#[doc = "!< Port 4 Pin 0"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P4_0: cyhal_gpio_psoc6_02_124_bga_t = 32;
#[doc = "!< Port 4 Pin 1"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P4_1: cyhal_gpio_psoc6_02_124_bga_t = 33;
#[doc = "!< Port 5 Pin 0"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P5_0: cyhal_gpio_psoc6_02_124_bga_t = 40;
#[doc = "!< Port 5 Pin 1"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P5_1: cyhal_gpio_psoc6_02_124_bga_t = 41;
#[doc = "!< Port 5 Pin 2"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P5_2: cyhal_gpio_psoc6_02_124_bga_t = 42;
#[doc = "!< Port 5 Pin 3"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P5_3: cyhal_gpio_psoc6_02_124_bga_t = 43;
#[doc = "!< Port 5 Pin 4"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P5_4: cyhal_gpio_psoc6_02_124_bga_t = 44;
#[doc = "!< Port 5 Pin 5"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P5_5: cyhal_gpio_psoc6_02_124_bga_t = 45;
#[doc = "!< Port 5 Pin 6"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P5_6: cyhal_gpio_psoc6_02_124_bga_t = 46;
#[doc = "!< Port 5 Pin 7"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P5_7: cyhal_gpio_psoc6_02_124_bga_t = 47;
#[doc = "!< Port 6 Pin 0"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P6_0: cyhal_gpio_psoc6_02_124_bga_t = 48;
#[doc = "!< Port 6 Pin 1"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P6_1: cyhal_gpio_psoc6_02_124_bga_t = 49;
#[doc = "!< Port 6 Pin 2"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P6_2: cyhal_gpio_psoc6_02_124_bga_t = 50;
#[doc = "!< Port 6 Pin 3"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P6_3: cyhal_gpio_psoc6_02_124_bga_t = 51;
#[doc = "!< Port 6 Pin 4"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P6_4: cyhal_gpio_psoc6_02_124_bga_t = 52;
#[doc = "!< Port 6 Pin 5"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P6_5: cyhal_gpio_psoc6_02_124_bga_t = 53;
#[doc = "!< Port 6 Pin 6"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P6_6: cyhal_gpio_psoc6_02_124_bga_t = 54;
#[doc = "!< Port 6 Pin 7"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P6_7: cyhal_gpio_psoc6_02_124_bga_t = 55;
#[doc = "!< Port 7 Pin 0"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P7_0: cyhal_gpio_psoc6_02_124_bga_t = 56;
#[doc = "!< Port 7 Pin 1"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P7_1: cyhal_gpio_psoc6_02_124_bga_t = 57;
#[doc = "!< Port 7 Pin 2"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P7_2: cyhal_gpio_psoc6_02_124_bga_t = 58;
#[doc = "!< Port 7 Pin 3"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P7_3: cyhal_gpio_psoc6_02_124_bga_t = 59;
#[doc = "!< Port 7 Pin 4"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P7_4: cyhal_gpio_psoc6_02_124_bga_t = 60;
#[doc = "!< Port 7 Pin 5"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P7_5: cyhal_gpio_psoc6_02_124_bga_t = 61;
#[doc = "!< Port 7 Pin 6"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P7_6: cyhal_gpio_psoc6_02_124_bga_t = 62;
#[doc = "!< Port 7 Pin 7"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P7_7: cyhal_gpio_psoc6_02_124_bga_t = 63;
#[doc = "!< Port 8 Pin 0"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P8_0: cyhal_gpio_psoc6_02_124_bga_t = 64;
#[doc = "!< Port 8 Pin 1"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P8_1: cyhal_gpio_psoc6_02_124_bga_t = 65;
#[doc = "!< Port 8 Pin 2"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P8_2: cyhal_gpio_psoc6_02_124_bga_t = 66;
#[doc = "!< Port 8 Pin 3"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P8_3: cyhal_gpio_psoc6_02_124_bga_t = 67;
#[doc = "!< Port 8 Pin 4"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P8_4: cyhal_gpio_psoc6_02_124_bga_t = 68;
#[doc = "!< Port 8 Pin 5"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P8_5: cyhal_gpio_psoc6_02_124_bga_t = 69;
#[doc = "!< Port 8 Pin 6"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P8_6: cyhal_gpio_psoc6_02_124_bga_t = 70;
#[doc = "!< Port 8 Pin 7"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P8_7: cyhal_gpio_psoc6_02_124_bga_t = 71;
#[doc = "!< Port 9 Pin 0"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P9_0: cyhal_gpio_psoc6_02_124_bga_t = 72;
#[doc = "!< Port 9 Pin 1"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P9_1: cyhal_gpio_psoc6_02_124_bga_t = 73;
#[doc = "!< Port 9 Pin 2"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P9_2: cyhal_gpio_psoc6_02_124_bga_t = 74;
#[doc = "!< Port 9 Pin 3"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P9_3: cyhal_gpio_psoc6_02_124_bga_t = 75;
#[doc = "!< Port 9 Pin 4"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P9_4: cyhal_gpio_psoc6_02_124_bga_t = 76;
#[doc = "!< Port 9 Pin 5"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P9_5: cyhal_gpio_psoc6_02_124_bga_t = 77;
#[doc = "!< Port 9 Pin 6"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P9_6: cyhal_gpio_psoc6_02_124_bga_t = 78;
#[doc = "!< Port 9 Pin 7"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P9_7: cyhal_gpio_psoc6_02_124_bga_t = 79;
#[doc = "!< Port 10 Pin 0"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P10_0: cyhal_gpio_psoc6_02_124_bga_t = 80;
#[doc = "!< Port 10 Pin 1"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P10_1: cyhal_gpio_psoc6_02_124_bga_t = 81;
#[doc = "!< Port 10 Pin 2"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P10_2: cyhal_gpio_psoc6_02_124_bga_t = 82;
#[doc = "!< Port 10 Pin 3"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P10_3: cyhal_gpio_psoc6_02_124_bga_t = 83;
#[doc = "!< Port 10 Pin 4"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P10_4: cyhal_gpio_psoc6_02_124_bga_t = 84;
#[doc = "!< Port 10 Pin 5"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P10_5: cyhal_gpio_psoc6_02_124_bga_t = 85;
#[doc = "!< Port 10 Pin 6"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P10_6: cyhal_gpio_psoc6_02_124_bga_t = 86;
#[doc = "!< Port 10 Pin 7"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P10_7: cyhal_gpio_psoc6_02_124_bga_t = 87;
#[doc = "!< Port 11 Pin 0"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P11_0: cyhal_gpio_psoc6_02_124_bga_t = 88;
#[doc = "!< Port 11 Pin 1"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P11_1: cyhal_gpio_psoc6_02_124_bga_t = 89;
#[doc = "!< Port 11 Pin 2"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P11_2: cyhal_gpio_psoc6_02_124_bga_t = 90;
#[doc = "!< Port 11 Pin 3"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P11_3: cyhal_gpio_psoc6_02_124_bga_t = 91;
#[doc = "!< Port 11 Pin 4"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P11_4: cyhal_gpio_psoc6_02_124_bga_t = 92;
#[doc = "!< Port 11 Pin 5"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P11_5: cyhal_gpio_psoc6_02_124_bga_t = 93;
#[doc = "!< Port 11 Pin 6"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P11_6: cyhal_gpio_psoc6_02_124_bga_t = 94;
#[doc = "!< Port 11 Pin 7"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P11_7: cyhal_gpio_psoc6_02_124_bga_t = 95;
#[doc = "!< Port 12 Pin 0"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P12_0: cyhal_gpio_psoc6_02_124_bga_t = 96;
#[doc = "!< Port 12 Pin 1"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P12_1: cyhal_gpio_psoc6_02_124_bga_t = 97;
#[doc = "!< Port 12 Pin 2"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P12_2: cyhal_gpio_psoc6_02_124_bga_t = 98;
#[doc = "!< Port 12 Pin 3"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P12_3: cyhal_gpio_psoc6_02_124_bga_t = 99;
#[doc = "!< Port 12 Pin 4"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P12_4: cyhal_gpio_psoc6_02_124_bga_t = 100;
#[doc = "!< Port 12 Pin 5"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P12_5: cyhal_gpio_psoc6_02_124_bga_t = 101;
#[doc = "!< Port 12 Pin 6"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P12_6: cyhal_gpio_psoc6_02_124_bga_t = 102;
#[doc = "!< Port 12 Pin 7"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P12_7: cyhal_gpio_psoc6_02_124_bga_t = 103;
#[doc = "!< Port 13 Pin 0"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P13_0: cyhal_gpio_psoc6_02_124_bga_t = 104;
#[doc = "!< Port 13 Pin 1"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P13_1: cyhal_gpio_psoc6_02_124_bga_t = 105;
#[doc = "!< Port 13 Pin 2"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P13_2: cyhal_gpio_psoc6_02_124_bga_t = 106;
#[doc = "!< Port 13 Pin 3"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P13_3: cyhal_gpio_psoc6_02_124_bga_t = 107;
#[doc = "!< Port 13 Pin 4"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P13_4: cyhal_gpio_psoc6_02_124_bga_t = 108;
#[doc = "!< Port 13 Pin 5"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P13_5: cyhal_gpio_psoc6_02_124_bga_t = 109;
#[doc = "!< Port 13 Pin 6"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P13_6: cyhal_gpio_psoc6_02_124_bga_t = 110;
#[doc = "!< Port 13 Pin 7"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P13_7: cyhal_gpio_psoc6_02_124_bga_t = 111;
#[doc = "!< Port 14 Pin 0"]
pub const cyhal_gpio_psoc6_02_124_bga_t_USBDP: cyhal_gpio_psoc6_02_124_bga_t = 112;
#[doc = "!< Port 14 Pin 0"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P14_0: cyhal_gpio_psoc6_02_124_bga_t = 112;
#[doc = "!< Port 14 Pin 1"]
pub const cyhal_gpio_psoc6_02_124_bga_t_USBDM: cyhal_gpio_psoc6_02_124_bga_t = 113;
#[doc = "!< Port 14 Pin 1"]
pub const cyhal_gpio_psoc6_02_124_bga_t_P14_1: cyhal_gpio_psoc6_02_124_bga_t = 113;
#[doc = " Definitions for all of the pins that are bonded out on in the 124-BGA package for the PSoC6_02 series."]
pub type cyhal_gpio_psoc6_02_124_bga_t = u32;
#[doc = " Create generic name for the series/package specific type."]
pub use self::cyhal_gpio_psoc6_02_124_bga_t as cyhal_gpio_t;
#[doc = " @brief Event callback data object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cyhal_event_callback_data_t {
    pub callback: cy_israddress,
    pub callback_arg: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_cyhal_event_callback_data_t() {
    const UNINIT: ::core::mem::MaybeUninit<cyhal_event_callback_data_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cyhal_event_callback_data_t>(),
        16usize,
        concat!("Size of: ", stringify!(cyhal_event_callback_data_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cyhal_event_callback_data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cyhal_event_callback_data_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_event_callback_data_t),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback_arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_event_callback_data_t),
            "::",
            stringify!(callback_arg)
        )
    );
}
#[doc = " @brief SPI object\n\n Application code should not rely on the specific contents of this struct.\n They are considered an implementation detail which is subject to change\n between platforms and/or HAL releases."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cyhal_spi_t {
    pub base: *mut CySCB_Type,
    pub resource: cyhal_resource_inst_t,
    pub pin_miso: cyhal_gpio_t,
    pub pin_mosi: cyhal_gpio_t,
    pub pin_sclk: cyhal_gpio_t,
    pub pin_ssel: [cyhal_gpio_t; 4usize],
    pub ssel_pol: [cy_en_scb_spi_polarity_t; 4usize],
    pub active_ssel: u8,
    pub clock: cyhal_clock_t,
    pub clk_mode: cy_en_scb_spi_sclk_mode_t,
    pub mode: u8,
    pub data_bits: u8,
    pub is_slave: bool,
    pub alloc_clock: bool,
    pub oversample_value: u8,
    pub msb_first: bool,
    pub context: cy_stc_scb_spi_context_t,
    pub irq_cause: u32,
    pub pending: u16,
    pub op_in_callback: bool,
    pub write_fill: u8,
    pub rx_buffer: *mut ::core::ffi::c_void,
    pub rx_buffer_size: u32,
    pub tx_buffer: *const ::core::ffi::c_void,
    pub tx_buffer_size: u32,
    pub is_async: bool,
    pub callback_data: cyhal_event_callback_data_t,
    pub dc_configured: bool,
}
#[test]
fn bindgen_test_layout_cyhal_spi_t() {
    const UNINIT: ::core::mem::MaybeUninit<cyhal_spi_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cyhal_spi_t>(),
        216usize,
        concat!("Size of: ", stringify!(cyhal_spi_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cyhal_spi_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cyhal_spi_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_spi_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).resource) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_spi_t),
            "::",
            stringify!(resource)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pin_miso) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_spi_t),
            "::",
            stringify!(pin_miso)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pin_mosi) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_spi_t),
            "::",
            stringify!(pin_mosi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pin_sclk) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_spi_t),
            "::",
            stringify!(pin_sclk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pin_ssel) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_spi_t),
            "::",
            stringify!(pin_ssel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssel_pol) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_spi_t),
            "::",
            stringify!(ssel_pol)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).active_ssel) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_spi_t),
            "::",
            stringify!(active_ssel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clock) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_spi_t),
            "::",
            stringify!(clock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clk_mode) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_spi_t),
            "::",
            stringify!(clk_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_spi_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_bits) as usize - ptr as usize },
        85usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_spi_t),
            "::",
            stringify!(data_bits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_slave) as usize - ptr as usize },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_spi_t),
            "::",
            stringify!(is_slave)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alloc_clock) as usize - ptr as usize },
        87usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_spi_t),
            "::",
            stringify!(alloc_clock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).oversample_value) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_spi_t),
            "::",
            stringify!(oversample_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msb_first) as usize - ptr as usize },
        89usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_spi_t),
            "::",
            stringify!(msb_first)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_spi_t),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).irq_cause) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_spi_t),
            "::",
            stringify!(irq_cause)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pending) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_spi_t),
            "::",
            stringify!(pending)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).op_in_callback) as usize - ptr as usize },
        158usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_spi_t),
            "::",
            stringify!(op_in_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write_fill) as usize - ptr as usize },
        159usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_spi_t),
            "::",
            stringify!(write_fill)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_buffer) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_spi_t),
            "::",
            stringify!(rx_buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_buffer_size) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_spi_t),
            "::",
            stringify!(rx_buffer_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_buffer) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_spi_t),
            "::",
            stringify!(tx_buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_buffer_size) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_spi_t),
            "::",
            stringify!(tx_buffer_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_async) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_spi_t),
            "::",
            stringify!(is_async)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback_data) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_spi_t),
            "::",
            stringify!(callback_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dc_configured) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(cyhal_spi_t),
            "::",
            stringify!(dc_configured)
        )
    );
}
pub const PCD_Register_CommandReg: PCD_Register = 2;
pub const PCD_Register_ComIEnReg: PCD_Register = 4;
pub const PCD_Register_DivIEnReg: PCD_Register = 6;
pub const PCD_Register_ComIrqReg: PCD_Register = 8;
pub const PCD_Register_DivIrqReg: PCD_Register = 10;
pub const PCD_Register_ErrorReg: PCD_Register = 12;
pub const PCD_Register_Status1Reg: PCD_Register = 14;
pub const PCD_Register_Status2Reg: PCD_Register = 16;
pub const PCD_Register_FIFODataReg: PCD_Register = 18;
pub const PCD_Register_FIFOLevelReg: PCD_Register = 20;
pub const PCD_Register_WaterLevelReg: PCD_Register = 22;
pub const PCD_Register_ControlReg: PCD_Register = 24;
pub const PCD_Register_BitFramingReg: PCD_Register = 26;
pub const PCD_Register_CollReg: PCD_Register = 28;
pub const PCD_Register_ModeReg: PCD_Register = 34;
pub const PCD_Register_TxModeReg: PCD_Register = 36;
pub const PCD_Register_RxModeReg: PCD_Register = 38;
pub const PCD_Register_TxControlReg: PCD_Register = 40;
pub const PCD_Register_TxASKReg: PCD_Register = 42;
pub const PCD_Register_TxSelReg: PCD_Register = 44;
pub const PCD_Register_RxSelReg: PCD_Register = 46;
pub const PCD_Register_RxThresholdReg: PCD_Register = 48;
pub const PCD_Register_DemodReg: PCD_Register = 50;
pub const PCD_Register_MfTxReg: PCD_Register = 56;
pub const PCD_Register_MfRxReg: PCD_Register = 58;
pub const PCD_Register_SerialSpeedReg: PCD_Register = 62;
pub const PCD_Register_CRCResultRegH: PCD_Register = 66;
pub const PCD_Register_CRCResultRegL: PCD_Register = 68;
pub const PCD_Register_ModWidthReg: PCD_Register = 72;
pub const PCD_Register_RFCfgReg: PCD_Register = 76;
pub const PCD_Register_GsNReg: PCD_Register = 78;
pub const PCD_Register_CWGsPReg: PCD_Register = 80;
pub const PCD_Register_ModGsPReg: PCD_Register = 82;
pub const PCD_Register_TModeReg: PCD_Register = 84;
pub const PCD_Register_TPrescalerReg: PCD_Register = 86;
pub const PCD_Register_TReloadRegH: PCD_Register = 88;
pub const PCD_Register_TReloadRegL: PCD_Register = 90;
pub const PCD_Register_TCntValueRegH: PCD_Register = 92;
pub const PCD_Register_TCntValueRegL: PCD_Register = 94;
pub const PCD_Register_TestSel1Reg: PCD_Register = 98;
pub const PCD_Register_TestSel2Reg: PCD_Register = 100;
pub const PCD_Register_TestPinEnReg: PCD_Register = 102;
pub const PCD_Register_TestPinValueReg: PCD_Register = 104;
pub const PCD_Register_TestBusReg: PCD_Register = 106;
pub const PCD_Register_AutoTestReg: PCD_Register = 108;
pub const PCD_Register_VersionReg: PCD_Register = 110;
pub const PCD_Register_AnalogTestReg: PCD_Register = 112;
pub const PCD_Register_TestDAC1Reg: PCD_Register = 114;
pub const PCD_Register_TestDAC2Reg: PCD_Register = 116;
pub const PCD_Register_TestADCReg: PCD_Register = 118;
#[doc = " MFRC522 registers (described in chapter 9 of the datasheet).\n When using SPI all addresses are shifted one bit left in the \"SPI address\n byte\" (section 8.1.2.3)"]
pub type PCD_Register = u32;
pub const PCD_Command_PCD_Idle: PCD_Command = 0;
pub const PCD_Command_PCD_Mem: PCD_Command = 1;
pub const PCD_Command_PCD_GenerateRandomID: PCD_Command = 2;
pub const PCD_Command_PCD_CalcCRC: PCD_Command = 3;
pub const PCD_Command_PCD_Transmit: PCD_Command = 4;
pub const PCD_Command_PCD_NoCmdChange: PCD_Command = 7;
pub const PCD_Command_PCD_Receive: PCD_Command = 8;
pub const PCD_Command_PCD_Transceive: PCD_Command = 12;
pub const PCD_Command_PCD_MFAuthent: PCD_Command = 14;
pub const PCD_Command_PCD_SoftReset: PCD_Command = 15;
pub type PCD_Command = u32;
pub const PICC_Command_PICC_CMD_REQA: PICC_Command = 38;
pub const PICC_Command_PICC_CMD_WUPA: PICC_Command = 82;
pub const PICC_Command_PICC_CMD_CT: PICC_Command = 136;
pub const PICC_Command_PICC_CMD_SEL_CL1: PICC_Command = 147;
pub const PICC_Command_PICC_CMD_SEL_CL2: PICC_Command = 149;
pub const PICC_Command_PICC_CMD_SEL_CL3: PICC_Command = 151;
pub const PICC_Command_PICC_CMD_HLTA: PICC_Command = 80;
pub const PICC_Command_PICC_CMD_MF_AUTH_KEY_A: PICC_Command = 96;
pub const PICC_Command_PICC_CMD_MF_AUTH_KEY_B: PICC_Command = 97;
pub const PICC_Command_PICC_CMD_MF_READ: PICC_Command = 48;
pub const PICC_Command_PICC_CMD_MF_WRITE: PICC_Command = 160;
pub const PICC_Command_PICC_CMD_MF_DECREMENT: PICC_Command = 192;
pub const PICC_Command_PICC_CMD_MF_INCREMENT: PICC_Command = 193;
pub const PICC_Command_PICC_CMD_MF_RESTORE: PICC_Command = 194;
pub const PICC_Command_PICC_CMD_MF_TRANSFER: PICC_Command = 176;
pub const PICC_Command_PICC_CMD_UL_WRITE: PICC_Command = 162;
pub type PICC_Command = u32;
pub const MIFARE_Misc_MF_ACK: MIFARE_Misc = 10;
pub const MIFARE_Misc_MF_KEY_SIZE: MIFARE_Misc = 6;
pub type MIFARE_Misc = u32;
pub const PICC_Type_PICC_TYPE_UNKNOWN: PICC_Type = 0;
pub const PICC_Type_PICC_TYPE_ISO_14443_4: PICC_Type = 1;
pub const PICC_Type_PICC_TYPE_ISO_18092: PICC_Type = 2;
pub const PICC_Type_PICC_TYPE_MIFARE_MINI: PICC_Type = 3;
pub const PICC_Type_PICC_TYPE_MIFARE_1K: PICC_Type = 4;
pub const PICC_Type_PICC_TYPE_MIFARE_4K: PICC_Type = 5;
pub const PICC_Type_PICC_TYPE_MIFARE_UL: PICC_Type = 6;
pub const PICC_Type_PICC_TYPE_MIFARE_PLUS: PICC_Type = 7;
pub const PICC_Type_PICC_TYPE_TNP3XXX: PICC_Type = 8;
pub const PICC_Type_PICC_TYPE_NOT_COMPLETE: PICC_Type = 255;
pub type PICC_Type = u32;
pub const StatusCode_STATUS_OK: StatusCode = 1;
pub const StatusCode_STATUS_ERROR: StatusCode = 2;
pub const StatusCode_STATUS_COLLISION: StatusCode = 3;
pub const StatusCode_STATUS_TIMEOUT: StatusCode = 4;
pub const StatusCode_STATUS_NO_ROOM: StatusCode = 5;
pub const StatusCode_STATUS_INTERNAL_ERROR: StatusCode = 6;
pub const StatusCode_STATUS_INVALID: StatusCode = 7;
pub const StatusCode_STATUS_CRC_WRONG: StatusCode = 8;
pub const StatusCode_STATUS_MIFARE_NACK: StatusCode = 9;
pub type StatusCode = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Uid {
    pub size: u8,
    pub uidByte: [u8; 10usize],
    pub sak: u8,
}
#[test]
fn bindgen_test_layout_Uid() {
    const UNINIT: ::core::mem::MaybeUninit<Uid> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Uid>(),
        12usize,
        concat!("Size of: ", stringify!(Uid))
    );
    assert_eq!(
        ::core::mem::align_of::<Uid>(),
        1usize,
        concat!("Alignment of ", stringify!(Uid))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Uid), "::", stringify!(size))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uidByte) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Uid),
            "::",
            stringify!(uidByte)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sak) as usize - ptr as usize },
        11usize,
        concat!("Offset of field: ", stringify!(Uid), "::", stringify!(sak))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MIFARE_Key {
    pub keyByte: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_MIFARE_Key() {
    const UNINIT: ::core::mem::MaybeUninit<MIFARE_Key> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MIFARE_Key>(),
        6usize,
        concat!("Size of: ", stringify!(MIFARE_Key))
    );
    assert_eq!(
        ::core::mem::align_of::<MIFARE_Key>(),
        1usize,
        concat!("Alignment of ", stringify!(MIFARE_Key))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keyByte) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MIFARE_Key),
            "::",
            stringify!(keyByte)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mfrc522_t {
    pub m_SPI: cyhal_spi_t,
    pub m_reset: cyhal_gpio_t,
    pub m_cs: cyhal_gpio_t,
    pub uid: Uid,
}
#[test]
fn bindgen_test_layout_mfrc522_t() {
    const UNINIT: ::core::mem::MaybeUninit<mfrc522_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mfrc522_t>(),
        240usize,
        concat!("Size of: ", stringify!(mfrc522_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mfrc522_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mfrc522_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_SPI) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mfrc522_t),
            "::",
            stringify!(m_SPI)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_reset) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(mfrc522_t),
            "::",
            stringify!(m_reset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m_cs) as usize - ptr as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(mfrc522_t),
            "::",
            stringify!(m_cs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(mfrc522_t),
            "::",
            stringify!(uid)
        )
    );
}
extern "C" {
    #[doc = " Setup GPIOs and SPI for the MFRC522."]
    pub fn MFRC522_Init(
        mfrc: *mut mfrc522_t,
        mosi: cyhal_gpio_t,
        miso: cyhal_gpio_t,
        sclk: cyhal_gpio_t,
        cs: cyhal_gpio_t,
        reset: cyhal_gpio_t,
    );
}
extern "C" {
    #[doc = " Initializes the MFRC522 chip."]
    pub fn PCD_Init(mfrc: *mut mfrc522_t);
}
extern "C" {
    #[doc = " Performs a soft reset on the MFRC522 chip and waits for it to be ready\n again."]
    pub fn PCD_Reset(mfrc: *mut mfrc522_t);
}
extern "C" {
    #[doc = " Turns the antenna on by enabling pins TX1 and TX2.\n After a reset these pins disabled."]
    pub fn PCD_AntennaOn(mfrc: *mut mfrc522_t);
}
extern "C" {
    #[doc = " Writes a byte to the specified register in the MFRC522 chip.\n The interface is described in the datasheet section 8.1.2.\n\n @param reg   The register to write to. One of the PCD_Register enums.\n @param value The value to write."]
    pub fn PCD_WriteRegister(mfrc: *mut mfrc522_t, reg: u8, value: u8);
}
extern "C" {
    #[doc = " Writes a number of bytes to the specified register in the MFRC522 chip.\n The interface is described in the datasheet section 8.1.2.\n\n @param reg    The register to write to. One of the PCD_Register enums.\n @param count  The number of bytes to write to the register\n @param values The values to write. Byte array."]
    pub fn PCD_WriteRegisterBytes(mfrc: *mut mfrc522_t, reg: u8, count: u8, values: *mut u8);
}
extern "C" {
    #[doc = " Reads a byte from the specified register in the MFRC522 chip.\n The interface is described in the datasheet section 8.1.2.\n\n @param reg The register to read from. One of the PCD_Register enums.\n @returns Register value"]
    pub fn PCD_ReadRegister(mfrc: *mut mfrc522_t, reg: u8) -> u8;
}
extern "C" {
    #[doc = " Reads a number of bytes from the specified register in the MFRC522 chip.\n The interface is described in the datasheet section 8.1.2.\n\n @param reg     The register to read from. One of the PCD_Register enums.\n @param count   The number of bytes to read.\n @param values  Byte array to store the values in.\n @param rxAlign Only bit positions rxAlign..7 in values[0] are updated."]
    pub fn PCD_ReadRegisterBytes(
        mfrc: *mut mfrc522_t,
        reg: u8,
        count: u8,
        values: *mut u8,
        rxAlign: u8,
    );
}
extern "C" {
    #[doc = " Sets the bits given in mask in register reg.\n\n @param reg  The register to update. One of the PCD_Register enums.\n @param mask The bits to set."]
    pub fn PCD_SetRegisterBits(mfrc: *mut mfrc522_t, reg: u8, mask: u8);
}
extern "C" {
    #[doc = " Clears the bits given in mask from register reg.\n\n @param reg  The register to update. One of the PCD_Register enums.\n @param mask The bits to clear."]
    pub fn PCD_ClrRegisterBits(mfrc: *mut mfrc522_t, reg: u8, mask: u8);
}
extern "C" {
    #[doc = " Use the CRC coprocessor in the MFRC522 to calculate a CRC_A.\n\n @param data   Pointer to the data to transfer to the FIFO for CRC\n calculation.\n @param length The number of bytes to transfer.\n @param result Pointer to result buffer. Result is written to result[0..1],\n low byte first.\n @return STATUS_OK on success, STATUS_??? otherwise."]
    pub fn PCD_CalculateCRC(mfrc: *mut mfrc522_t, data: *mut u8, length: u8, result: *mut u8)
        -> u8;
}
extern "C" {
    #[doc = " Executes the Transceive command.\n CRC validation can only be done if backData and backLen are specified.\n\n @param sendData Pointer to the data to transfer to the FIFO.\n @param sendLen  Number of bytes to transfer to the FIFO.\n @param backData NULL or pointer to buffer if data should be read back after\n executing the command.\n @param backLen  Max number of bytes to write to *backData. Out: The number\n of bytes returned.\n @param validBits The number of valid bits in the last byte. 0 for 8 valid\n bits. Default NULL.\n @param rxAlign  Defines the bit position in backData[0] for the first bit\n received. Default 0.\n @param checkCRC True => The last two bytes of the response is assumed to be\n a CRC_A that must be validated.\n\n @return STATUS_OK on success, STATUS_??? otherwise."]
    pub fn PCD_TransceiveData(
        mfrc: *mut mfrc522_t,
        sendData: *mut u8,
        sendLen: u8,
        backData: *mut u8,
        backLen: *mut u8,
        validBits: *mut u8,
        rxAlign: u8,
        checkCRC: bool,
    ) -> u8;
}
extern "C" {
    #[doc = " Transfers data to the MFRC522 FIFO, executes a commend, waits for\n completion and transfers data back from the FIFO. CRC validation can only\n be done if backData and backLen are specified.\n\n @param command   The command to execute. One of the PCD_Command enums.\n @param waitIRq   The bits in the ComIrqReg register that signals successful\n completion of the command.\n @param sendData  Pointer to the data to transfer to the FIFO.\n @param sendLen   Number of bytes to transfer to the FIFO.\n @param backData  NULL or pointer to buffer if data should be read back\n after executing the command.\n @param backLen   In: Max number of bytes to write to *backData. Out: The\n number of bytes returned.\n @param validBits In/Out: The number of valid bits in the last byte. 0 for 8\n valid bits.\n @param rxAlign   In: Defines the bit position in backData[0] for the first\n bit received. Default 0.\n @param checkCRC  In: True => The last two bytes of the response is assumed\n to be a CRC_A that must be validated.\n\n @return STATUS_OK on success, STATUS_??? otherwise."]
    pub fn PCD_CommunicateWithPICC(
        mfrc: *mut mfrc522_t,
        command: u8,
        waitIRq: u8,
        sendData: *mut u8,
        sendLen: u8,
        backData: *mut u8,
        backLen: *mut u8,
        validBits: *mut u8,
        rxAlign: u8,
        checkCRC: bool,
    ) -> u8;
}
extern "C" {
    #[doc = " Transmits a REQuest command, Type A. Invites PICCs in state IDLE to go to\n READY and prepare for anticollision or selection. 7 bit frame. Beware: When\n two PICCs are in the field at the same time I often get STATUS_TIMEOUT -\n probably due do bad antenna design.\n\n @param bufferATQA  The buffer to store the ATQA (Answer to request) in\n @param bufferSize  Buffer size, at least two bytes. Also number of bytes\n returned if STATUS_OK.\n\n @return STATUS_OK on success, STATUS_??? otherwise."]
    pub fn PICC_RequestA(mfrc: *mut mfrc522_t, bufferATQA: *mut u8, bufferSize: *mut u8) -> u8;
}
extern "C" {
    #[doc = " Transmits a Wake-UP command, Type A. Invites PICCs in state IDLE and HALT\n to go to READY(*) and prepare for anticollision or selection. 7 bit frame.\n Beware: When two PICCs are in the field at the same time I often get\n STATUS_TIMEOUT - probably due do bad antenna design.\n\n @param bufferATQA  The buffer to store the ATQA (Answer to request) in\n @param bufferSize  Buffer size, at least two bytes. Also number of bytes\n returned if STATUS_OK.\n\n @return STATUS_OK on success, STATUS_??? otherwise."]
    pub fn PICC_WakeupA(mfrc: *mut mfrc522_t, bufferATQA: *mut u8, bufferSize: *mut u8) -> u8;
}
extern "C" {
    #[doc = " Transmits REQA or WUPA commands.\n Beware: When two PICCs are in the field at the same time I often get\n STATUS_TIMEOUT - probably due do bad antenna design.\n\n @param command     The command to send - PICC_CMD_REQA or PICC_CMD_WUPA\n @param bufferATQA  The buffer to store the ATQA (Answer to request) in\n @param bufferSize  Buffer size, at least two bytes. Also number of bytes\n returned if STATUS_OK.\n\n @return STATUS_OK on success, STATUS_??? otherwise."]
    pub fn PICC_REQA_or_WUPA(
        mfrc: *mut mfrc522_t,
        command: u8,
        bufferATQA: *mut u8,
        bufferSize: *mut u8,
    ) -> u8;
}
extern "C" {
    #[doc = " Transmits SELECT/ANTICOLLISION commands to select a single PICC.\n Before calling this function the PICCs must be placed in the READY(*) state\n by calling PICC_RequestA() or PICC_WakeupA(). On success:\n   - The chosen PICC is in state ACTIVE(*) and all other PICCs have returned\n to state IDLE/HALT. (Figure 7 of the ISO/IEC 14443-3 draft.)\n   - The UID size and value of the chosen PICC is returned in *uid along\n with the SAK.\n\n A PICC UID consists of 4, 7 or 10 bytes.\n Only 4 bytes can be specified in a SELECT command, so for the longer UIDs\n two or three iterations are used:\n\n   UID size        Number of UID bytes                Cascade levels Example\n of PICC\n   ========        ===================                ==============\n =============== single                   4                                1\n MIFARE Classic double                   7                                2\n MIFARE Ultralight triple                  10 3                      Not\n currently in use?\n\n\n @param uid        Pointer to Uid struct. Normally output, but can also be\n used to supply a known UID.\n @param validBits  The number of known UID bits supplied in *uid. Normally\n 0. If set you must also supply uid->size.\n\n @return STATUS_OK on success, STATUS_??? otherwise."]
    pub fn PICC_Select(mfrc: *mut mfrc522_t, uid: *mut Uid, validBits: u8) -> u8;
}
extern "C" {
    #[doc = " Instructs a PICC in state ACTIVE(*) to go to state HALT.\n\n @return STATUS_OK on success, STATUS_??? otherwise."]
    pub fn PICC_HaltA(mfrc: *mut mfrc522_t) -> u8;
}
extern "C" {
    #[doc = " Executes the MFRC522 MFAuthent command.\n This command manages MIFARE authentication to enable a secure communication\n to any MIFARE Mini, MIFARE 1K and MIFARE 4K card. The authentication is\n described in the MFRC522 datasheet section 10.3.1.9 and\n http://www.nxp.com/documents/data_sheet/MF1S503x.pdf section 10.1. For use\n with MIFARE Classic PICCs. The PICC must be selected - ie in state\n ACTIVE(*) - before calling this function. Remember to call\n PCD_StopCrypto1() after communicating with the authenticated PICC -\n otherwise no new communications can start.\n\n All keys are set to FFFFFFFFFFFFh at chip delivery.\n\n @param command    PICC_CMD_MF_AUTH_KEY_A or PICC_CMD_MF_AUTH_KEY_B\n @param blockAddr  The block number. See numbering in the comments in the .h\n file.\n @param key        Pointer to the Crypteo1 key to use (6 bytes)\n @param uid        Pointer to Uid struct. The first 4 bytes of the UID is\n used.\n\n @return STATUS_OK on success, STATUS_??? otherwise. Probably STATUS_TIMEOUT\n if you supply the wrong key."]
    pub fn PCD_Authenticate(
        mfrc: *mut mfrc522_t,
        command: u8,
        blockAddr: u8,
        key: *mut MIFARE_Key,
        uid: *mut Uid,
    ) -> u8;
}
extern "C" {
    #[doc = " Used to exit the PCD from its authenticated state.\n Remember to call this function after communicating with an authenticated\n PICC - otherwise no new communications can start."]
    pub fn PCD_StopCrypto1(mfrc: *mut mfrc522_t);
}
extern "C" {
    #[doc = " Reads 16 bytes (+ 2 bytes CRC_A) from the active PICC.\n\n For MIFARE Classic the sector containing the block must be authenticated\n before calling this function.\n\n For MIFARE Ultralight only addresses 00h to 0Fh are decoded.\n The MF0ICU1 returns a NAK for higher addresses.\n The MF0ICU1 responds to the READ command by sending 16 bytes starting from\n the page address defined by the command argument. For example; if blockAddr\n is 03h then pages 03h, 04h, 05h, 06h are returned. A roll-back is\n implemented: If blockAddr is 0Eh, then the contents of pages 0Eh, 0Fh, 00h\n and 01h are returned.\n\n The buffer must be at least 18 bytes because a CRC_A is also returned.\n Checks the CRC_A before returning STATUS_OK.\n\n @param blockAddr  MIFARE Classic: The block (0-0xff) number. MIFARE\n Ultralight: The first page to return data from.\n @param buffer     The buffer to store the data in\n @param bufferSize Buffer size, at least 18 bytes. Also number of bytes\n returned if STATUS_OK.\n\n @return STATUS_OK on success, STATUS_??? otherwise."]
    pub fn MIFARE_Read(
        mfrc: *mut mfrc522_t,
        blockAddr: u8,
        buffer: *mut u8,
        bufferSize: *mut u8,
    ) -> u8;
}
extern "C" {
    #[doc = " Writes 16 bytes to the active PICC.\n\n For MIFARE Classic the sector containing the block must be authenticated\n before calling this function.\n\n For MIFARE Ultralight the opretaion is called \"COMPATIBILITY WRITE\".\n Even though 16 bytes are transferred to the Ultralight PICC, only the least\n significant 4 bytes (bytes 0 to 3) are written to the specified address. It\n is recommended to set the remaining bytes 04h to 0Fh to all logic 0.\n\n @param blockAddr  MIFARE Classic: The block (0-0xff) number. MIFARE\n Ultralight: The page (2-15) to write to.\n @param buffer     The 16 bytes to write to the PICC\n @param bufferSize Buffer size, must be at least 16 bytes. Exactly 16 bytes\n are written.\n\n @return STATUS_OK on success, STATUS_??? otherwise."]
    pub fn MIFARE_Write(mfrc: *mut mfrc522_t, blockAddr: u8, buffer: *mut u8, bufferSize: u8)
        -> u8;
}
extern "C" {
    #[doc = " Writes a 4 byte page to the active MIFARE Ultralight PICC.\n\n @param page       The page (2-15) to write to.\n @param buffer     The 4 bytes to write to the PICC\n @param bufferSize Buffer size, must be at least 4 bytes. Exactly 4 bytes\n are written.\n\n @return STATUS_OK on success, STATUS_??? otherwise."]
    pub fn MIFARE_UltralightWrite(
        mfrc: *mut mfrc522_t,
        page: u8,
        buffer: *mut u8,
        bufferSize: u8,
    ) -> u8;
}
extern "C" {
    #[doc = " MIFARE Decrement subtracts the delta from the value of the addressed block,\n and stores the result in a volatile memory. For MIFARE Classic only. The\n sector containing the block must be authenticated before calling this\n function. Only for blocks in \"value block\" mode, ie with access bits [C1 C2\n C3] = [110] or [001]. Use MIFARE_Transfer() to store the result in a block.\n\n @param blockAddr The block (0-0xff) number.\n @param delta     This number is subtracted from the value of block\n blockAddr.\n\n @return STATUS_OK on success, STATUS_??? otherwise."]
    pub fn MIFARE_Decrement(mfrc: *mut mfrc522_t, blockAddr: u8, delta: u32) -> u8;
}
extern "C" {
    #[doc = " MIFARE Increment adds the delta to the value of the addressed block, and\n stores the result in a volatile memory. For MIFARE Classic only. The sector\n containing the block must be authenticated before calling this function.\n Only for blocks in \"value block\" mode, ie with access bits [C1 C2 C3] =\n [110] or [001]. Use MIFARE_Transfer() to store the result in a block.\n\n @param blockAddr The block (0-0xff) number.\n @param delta     This number is added to the value of block blockAddr.\n\n @return STATUS_OK on success, STATUS_??? otherwise."]
    pub fn MIFARE_Increment(mfrc: *mut mfrc522_t, blockAddr: u8, delta: u32) -> u8;
}
extern "C" {
    #[doc = " MIFARE Restore copies the value of the addressed block into a volatile\n memory. For MIFARE Classic only. The sector containing the block must be\n authenticated before calling this function. Only for blocks in \"value\n block\" mode, ie with access bits [C1 C2 C3] = [110] or [001]. Use\n MIFARE_Transfer() to store the result in a block.\n\n @param blockAddr The block (0-0xff) number.\n\n @return STATUS_OK on success, STATUS_??? otherwise."]
    pub fn MIFARE_Restore(mfrc: *mut mfrc522_t, blockAddr: u8) -> u8;
}
extern "C" {
    #[doc = " MIFARE Transfer writes the value stored in the volatile memory into one\n MIFARE Classic block. For MIFARE Classic only. The sector containing the\n block must be authenticated before calling this function. Only for blocks\n in \"value block\" mode, ie with access bits [C1 C2 C3] = [110] or [001].\n\n @param blockAddr The block (0-0xff) number.\n\n @return STATUS_OK on success, STATUS_??? otherwise."]
    pub fn MIFARE_Transfer(mfrc: *mut mfrc522_t, blockAddr: u8) -> u8;
}
extern "C" {
    #[doc = " Wrapper for MIFARE protocol communication.\n Adds CRC_A, executes the Transceive command and checks that the response is\n MF_ACK or a timeout.\n\n @param sendData      Pointer to the data to transfer to the FIFO. Do NOT\n include the CRC_A.\n @param sendLen       Number of bytes in sendData.\n @param acceptTimeout True => A timeout is also success\n\n @return STATUS_OK on success, STATUS_??? otherwise."]
    pub fn PCD_MIFARE_Transceive(
        mfrc: *mut mfrc522_t,
        sendData: *mut u8,
        sendLen: u8,
        acceptTimeout: bool,
    ) -> u8;
}
extern "C" {
    #[doc = " Translates the SAK (Select Acknowledge) to a PICC type.\n\n @param sak The SAK byte returned from PICC_Select().\n\n @return PICC_Type"]
    pub fn PICC_GetType(mfrc: *mut mfrc522_t, sak: u8) -> u8;
}
extern "C" {
    #[doc = " Returns a string pointer to the PICC type name.\n\n @param type One of the PICC_Type enums.\n\n @return A string pointer to the PICC type name."]
    pub fn PICC_GetTypeName(mfrc: *mut mfrc522_t, type_: u8) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Returns a string pointer to a status code name.\n\n @param code One of the StatusCode enums.\n\n @return A string pointer to a status code name."]
    pub fn GetStatusCodeName(mfrc: *mut mfrc522_t, code: u8) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Calculates the bit pattern needed for the specified access bits. In the [C1\n C2 C3] tupples C1 is MSB (=4) and C3 is LSB (=1).\n\n @param accessBitBuffer Pointer to byte 6, 7 and 8 in the sector trailer.\n Bytes [0..2] will be set.\n @param g0              Access bits [C1 C2 C3] for block 0 (for sectors\n 0-31) or blocks 0-4 (for sectors 32-39)\n @param g1              Access bits [C1 C2 C3] for block 1 (for sectors\n 0-31) or blocks 5-9 (for sectors 32-39)\n @param g2              Access bits [C1 C2 C3] for block 2 (for sectors\n 0-31) or blocks 10-14 (for sectors 32-39)\n @param g3              Access bits [C1 C2 C3] for the sector trailer, block\n 3 (for sectors 0-31) or block 15 (for sectors 32-39)"]
    pub fn MIFARE_SetAccessBits(
        mfrc: *mut mfrc522_t,
        accessBitBuffer: *mut u8,
        g0: u8,
        g1: u8,
        g2: u8,
        g3: u8,
    );
}
extern "C" {
    #[doc = " Returns true if a PICC responds to PICC_CMD_REQA.\n Only \"new\" cards in state IDLE are invited. Sleeping cards in state HALT\n are ignored.\n\n @return bool"]
    pub fn PICC_IsNewCardPresent(mfrc: *mut mfrc522_t) -> bool;
}
extern "C" {
    #[doc = " Simple wrapper around PICC_Select.\n Returns true if a UID could be read.\n Remember to call PICC_IsNewCardPresent(), PICC_RequestA() or PICC_WakeupA()\n first. The read UID is available in the class variable uid.\n\n @return bool"]
    pub fn PICC_ReadCardSerial(mfrc: *mut mfrc522_t) -> bool;
}
